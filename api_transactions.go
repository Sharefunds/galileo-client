
/*
 * Program API
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * API version: 4.0
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package swagger

import (
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type TransactionsApiService service
/*
TransactionsApiService Add ACH Account
Use the Add ACH Account endpoint to add an ACH account to the specified customer account. If you are integrated with Plaid, set the RPVIR parameter to &#x60;1&#x60; to receive &#x60;plaid_identity_values&#x60; in the response. Use this endpoint to add external accounts that belong to individuals. For accounts that belong to companies, use the &lt;a href&#x3D;\&quot;ref:post_addachaccountcorporate\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Add ACH Account Corporate&lt;/a&gt; endpoint.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *TransactionsApiPostAddachaccountOpts - Optional Parameters:
     * @param "ApiLogin" (optional.String) - 
     * @param "ApiTransKey" (optional.String) - 
     * @param "ProviderId" (optional.Int32) - 
     * @param "TransactionId" (optional.String) - 
     * @param "AccountNo" (optional.String) - 
     * @param "Name" (optional.String) - 
     * @param "Type_" (optional.String) - 
     * @param "AchAccountNo" (optional.String) - 
     * @param "AchRoutingNo" (optional.String) - 
     * @param "Location" (optional.String) - 
     * @param "LocationType" (optional.Int32) - 
     * @param "ProcessorToken" (optional.String) - 
     * @param "VerifyIdentity" (optional.Int32) - 
     * @param "FirstName" (optional.String) - 
     * @param "LastName" (optional.String) - 
     * @param "FileFirstName" (optional.String) - 
     * @param "FileLastName" (optional.String) - 
     * @param "ResponseContentType" (optional.String) -  Use &#x60;xml&#x60; or &#x60;json&#x60; to specify the type of response. The default value is &#x60;xml&#x60;. Use this instead of the standard &#x60;accept&#x60; header.
@return InlineResponseDefault90
*/

type TransactionsApiPostAddachaccountOpts struct {
    ApiLogin optional.String
    ApiTransKey optional.String
    ProviderId optional.Int32
    TransactionId optional.String
    AccountNo optional.String
    Name optional.String
    Type_ optional.String
    AchAccountNo optional.String
    AchRoutingNo optional.String
    Location optional.String
    LocationType optional.Int32
    ProcessorToken optional.String
    VerifyIdentity optional.Int32
    FirstName optional.String
    LastName optional.String
    FileFirstName optional.String
    FileLastName optional.String
    ResponseContentType optional.String
}

func (a *TransactionsApiService) PostAddachaccount(ctx context.Context, localVarOptionals *TransactionsApiPostAddachaccountOpts) (InlineResponseDefault90, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponseDefault90
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/addAchAccount"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ResponseContentType.IsSet() {
		localVarHeaderParams["response-content-type"] = parameterToString(localVarOptionals.ResponseContentType.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.ApiLogin.IsSet() {
		localVarFormParams.Add("apiLogin", parameterToString(localVarOptionals.ApiLogin.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ApiTransKey.IsSet() {
		localVarFormParams.Add("apiTransKey", parameterToString(localVarOptionals.ApiTransKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderId.IsSet() {
		localVarFormParams.Add("providerId", parameterToString(localVarOptionals.ProviderId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TransactionId.IsSet() {
		localVarFormParams.Add("transactionId", parameterToString(localVarOptionals.TransactionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AccountNo.IsSet() {
		localVarFormParams.Add("accountNo", parameterToString(localVarOptionals.AccountNo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarFormParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarFormParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AchAccountNo.IsSet() {
		localVarFormParams.Add("achAccountNo", parameterToString(localVarOptionals.AchAccountNo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AchRoutingNo.IsSet() {
		localVarFormParams.Add("achRoutingNo", parameterToString(localVarOptionals.AchRoutingNo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Location.IsSet() {
		localVarFormParams.Add("location", parameterToString(localVarOptionals.Location.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LocationType.IsSet() {
		localVarFormParams.Add("locationType", parameterToString(localVarOptionals.LocationType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProcessorToken.IsSet() {
		localVarFormParams.Add("processorToken", parameterToString(localVarOptionals.ProcessorToken.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VerifyIdentity.IsSet() {
		localVarFormParams.Add("verifyIdentity", parameterToString(localVarOptionals.VerifyIdentity.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FirstName.IsSet() {
		localVarFormParams.Add("firstName", parameterToString(localVarOptionals.FirstName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LastName.IsSet() {
		localVarFormParams.Add("lastName", parameterToString(localVarOptionals.LastName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FileFirstName.IsSet() {
		localVarFormParams.Add("fileFirstName", parameterToString(localVarOptionals.FileFirstName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FileLastName.IsSet() {
		localVarFormParams.Add("fileLastName", parameterToString(localVarOptionals.FileLastName.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v InlineResponseDefault90
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
TransactionsApiService Add ACH Account Corporate
Use the Add ACH Account Corporate endpoint to add an ACH corporate account to the specified customer account. If you are integrated with Plaid, set the RPVIR parameter to &#x60;1&#x60; to receive &#x60;plaid_identity_values&#x60; in the response. Use this endpoint to add external accounts that belong to companies. For ACH accounts that belong to individuals, use the &lt;a href&#x3D;\&quot;ref:post_addachaccount\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Add ACH Account&lt;/a&gt; endpoint.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *TransactionsApiPostAddachaccountcorporateOpts - Optional Parameters:
     * @param "ApiLogin" (optional.String) - 
     * @param "ApiTransKey" (optional.String) - 
     * @param "ProviderId" (optional.Int32) - 
     * @param "TransactionId" (optional.String) - 
     * @param "AccountNo" (optional.String) - 
     * @param "Name" (optional.String) - 
     * @param "Type_" (optional.String) - 
     * @param "AchAccountNo" (optional.String) - 
     * @param "AchRoutingNo" (optional.String) - 
     * @param "Location" (optional.String) - 
     * @param "LocationType" (optional.Int32) - 
     * @param "ProcessorToken" (optional.String) - 
     * @param "VerifyIdentity" (optional.Int32) - 
     * @param "CompanyName" (optional.String) - 
     * @param "FileCompanyName" (optional.String) - 
     * @param "ResponseContentType" (optional.String) -  Use &#x60;xml&#x60; or &#x60;json&#x60; to specify the type of response. The default value is &#x60;xml&#x60;. Use this instead of the standard &#x60;accept&#x60; header.
@return InlineResponseDefault90
*/

type TransactionsApiPostAddachaccountcorporateOpts struct {
    ApiLogin optional.String
    ApiTransKey optional.String
    ProviderId optional.Int32
    TransactionId optional.String
    AccountNo optional.String
    Name optional.String
    Type_ optional.String
    AchAccountNo optional.String
    AchRoutingNo optional.String
    Location optional.String
    LocationType optional.Int32
    ProcessorToken optional.String
    VerifyIdentity optional.Int32
    CompanyName optional.String
    FileCompanyName optional.String
    ResponseContentType optional.String
}

func (a *TransactionsApiService) PostAddachaccountcorporate(ctx context.Context, localVarOptionals *TransactionsApiPostAddachaccountcorporateOpts) (InlineResponseDefault90, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponseDefault90
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/addAchAccountCorporate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ResponseContentType.IsSet() {
		localVarHeaderParams["response-content-type"] = parameterToString(localVarOptionals.ResponseContentType.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.ApiLogin.IsSet() {
		localVarFormParams.Add("apiLogin", parameterToString(localVarOptionals.ApiLogin.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ApiTransKey.IsSet() {
		localVarFormParams.Add("apiTransKey", parameterToString(localVarOptionals.ApiTransKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderId.IsSet() {
		localVarFormParams.Add("providerId", parameterToString(localVarOptionals.ProviderId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TransactionId.IsSet() {
		localVarFormParams.Add("transactionId", parameterToString(localVarOptionals.TransactionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AccountNo.IsSet() {
		localVarFormParams.Add("accountNo", parameterToString(localVarOptionals.AccountNo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarFormParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarFormParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AchAccountNo.IsSet() {
		localVarFormParams.Add("achAccountNo", parameterToString(localVarOptionals.AchAccountNo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AchRoutingNo.IsSet() {
		localVarFormParams.Add("achRoutingNo", parameterToString(localVarOptionals.AchRoutingNo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Location.IsSet() {
		localVarFormParams.Add("location", parameterToString(localVarOptionals.Location.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LocationType.IsSet() {
		localVarFormParams.Add("locationType", parameterToString(localVarOptionals.LocationType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProcessorToken.IsSet() {
		localVarFormParams.Add("processorToken", parameterToString(localVarOptionals.ProcessorToken.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VerifyIdentity.IsSet() {
		localVarFormParams.Add("verifyIdentity", parameterToString(localVarOptionals.VerifyIdentity.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CompanyName.IsSet() {
		localVarFormParams.Add("companyName", parameterToString(localVarOptionals.CompanyName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FileCompanyName.IsSet() {
		localVarFormParams.Add("fileCompanyName", parameterToString(localVarOptionals.FileCompanyName.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v InlineResponseDefault90
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
TransactionsApiService Add Paper Biller
Use the Add Paper Biller endpoint to create a custom paper biller for a customer and to schedule paper bill payments. Billers that are created with this endpoint will receive a paper check instead of an electronic payment.  See &lt;a href&#x3D;\&quot;doc:creating-a-billpay-transaction\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Creating a Billpay Transaction&lt;/a&gt; for instructions on using this endpoint.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *TransactionsApiPostAddpaperbillerOpts - Optional Parameters:
     * @param "ApiLogin" (optional.String) - 
     * @param "ApiTransKey" (optional.String) - 
     * @param "ProviderId" (optional.Int32) - 
     * @param "TransactionId" (optional.String) - 
     * @param "AccountNo" (optional.String) - 
     * @param "BillerName" (optional.String) - 
     * @param "BillerAddress1" (optional.String) - 
     * @param "BillerAddress2" (optional.String) - 
     * @param "BillerCity" (optional.String) - 
     * @param "BillerState" (optional.String) - 
     * @param "BillerZip" (optional.String) - 
     * @param "BillerPhone" (optional.String) - 
     * @param "BillerAccountNo" (optional.String) - 
     * @param "FrequencyType" (optional.String) - 
     * @param "NextDate" (optional.Time) - 
     * @param "EndDate" (optional.Time) - 
     * @param "Amount" (optional.Float32) - 
     * @param "ResponseContentType" (optional.String) -  Use &#x60;xml&#x60; or &#x60;json&#x60; to specify the type of response. The default value is &#x60;xml&#x60;. Use this instead of the standard &#x60;accept&#x60; header.
@return InlineResponseDefault10
*/

type TransactionsApiPostAddpaperbillerOpts struct {
    ApiLogin optional.String
    ApiTransKey optional.String
    ProviderId optional.Int32
    TransactionId optional.String
    AccountNo optional.String
    BillerName optional.String
    BillerAddress1 optional.String
    BillerAddress2 optional.String
    BillerCity optional.String
    BillerState optional.String
    BillerZip optional.String
    BillerPhone optional.String
    BillerAccountNo optional.String
    FrequencyType optional.String
    NextDate optional.Time
    EndDate optional.Time
    Amount optional.Float32
    ResponseContentType optional.String
}

func (a *TransactionsApiService) PostAddpaperbiller(ctx context.Context, localVarOptionals *TransactionsApiPostAddpaperbillerOpts) (InlineResponseDefault10, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponseDefault10
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/addPaperBiller"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ResponseContentType.IsSet() {
		localVarHeaderParams["response-content-type"] = parameterToString(localVarOptionals.ResponseContentType.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.ApiLogin.IsSet() {
		localVarFormParams.Add("apiLogin", parameterToString(localVarOptionals.ApiLogin.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ApiTransKey.IsSet() {
		localVarFormParams.Add("apiTransKey", parameterToString(localVarOptionals.ApiTransKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderId.IsSet() {
		localVarFormParams.Add("providerId", parameterToString(localVarOptionals.ProviderId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TransactionId.IsSet() {
		localVarFormParams.Add("transactionId", parameterToString(localVarOptionals.TransactionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AccountNo.IsSet() {
		localVarFormParams.Add("accountNo", parameterToString(localVarOptionals.AccountNo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BillerName.IsSet() {
		localVarFormParams.Add("billerName", parameterToString(localVarOptionals.BillerName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BillerAddress1.IsSet() {
		localVarFormParams.Add("billerAddress1", parameterToString(localVarOptionals.BillerAddress1.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BillerAddress2.IsSet() {
		localVarFormParams.Add("billerAddress2", parameterToString(localVarOptionals.BillerAddress2.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BillerCity.IsSet() {
		localVarFormParams.Add("billerCity", parameterToString(localVarOptionals.BillerCity.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BillerState.IsSet() {
		localVarFormParams.Add("billerState", parameterToString(localVarOptionals.BillerState.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BillerZip.IsSet() {
		localVarFormParams.Add("billerZip", parameterToString(localVarOptionals.BillerZip.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BillerPhone.IsSet() {
		localVarFormParams.Add("billerPhone", parameterToString(localVarOptionals.BillerPhone.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BillerAccountNo.IsSet() {
		localVarFormParams.Add("billerAccountNo", parameterToString(localVarOptionals.BillerAccountNo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FrequencyType.IsSet() {
		localVarFormParams.Add("frequencyType", parameterToString(localVarOptionals.FrequencyType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NextDate.IsSet() {
		localVarFormParams.Add("nextDate", parameterToString(localVarOptionals.NextDate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EndDate.IsSet() {
		localVarFormParams.Add("endDate", parameterToString(localVarOptionals.EndDate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Amount.IsSet() {
		localVarFormParams.Add("amount", parameterToString(localVarOptionals.Amount.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v InlineResponseDefault10
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
TransactionsApiService Add RPPS Biller
Use the Add RPPS Biller endpoint to create an &lt;&lt;glossary:RPPS&gt;&gt; biller for a customer and to schedule bill payments. Before calling this endpoint, use the &lt;a href&#x3D;\&quot;ref:post_searchbillerdirectory\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Search Biller Directory&lt;/a&gt; endpoint to find the biller and obtain the &#x60;rpps_biller_id&#x60;.  See &lt;a href&#x3D;\&quot;doc:creating-a-billpay-transaction\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Creating a Billpay Transaction&lt;/a&gt; for instructions on using this endpoint.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *TransactionsApiPostAddrppsbillerOpts - Optional Parameters:
     * @param "ApiLogin" (optional.String) - 
     * @param "ApiTransKey" (optional.String) - 
     * @param "ProviderId" (optional.Int32) - 
     * @param "TransactionId" (optional.String) - 
     * @param "AccountNo" (optional.String) - 
     * @param "RppsBillerId" (optional.String) - 
     * @param "BillerAccountNo" (optional.String) - 
     * @param "FrequencyType" (optional.String) - 
     * @param "NextDate" (optional.Time) - 
     * @param "EndDate" (optional.Time) - 
     * @param "Amount" (optional.Float32) - 
     * @param "ResponseContentType" (optional.String) -  Use &#x60;xml&#x60; or &#x60;json&#x60; to specify the type of response. The default value is &#x60;xml&#x60;. Use this instead of the standard &#x60;accept&#x60; header.
@return InlineResponseDefault12
*/

type TransactionsApiPostAddrppsbillerOpts struct {
    ApiLogin optional.String
    ApiTransKey optional.String
    ProviderId optional.Int32
    TransactionId optional.String
    AccountNo optional.String
    RppsBillerId optional.String
    BillerAccountNo optional.String
    FrequencyType optional.String
    NextDate optional.Time
    EndDate optional.Time
    Amount optional.Float32
    ResponseContentType optional.String
}

func (a *TransactionsApiService) PostAddrppsbiller(ctx context.Context, localVarOptionals *TransactionsApiPostAddrppsbillerOpts) (InlineResponseDefault12, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponseDefault12
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/addRppsBiller"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ResponseContentType.IsSet() {
		localVarHeaderParams["response-content-type"] = parameterToString(localVarOptionals.ResponseContentType.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.ApiLogin.IsSet() {
		localVarFormParams.Add("apiLogin", parameterToString(localVarOptionals.ApiLogin.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ApiTransKey.IsSet() {
		localVarFormParams.Add("apiTransKey", parameterToString(localVarOptionals.ApiTransKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderId.IsSet() {
		localVarFormParams.Add("providerId", parameterToString(localVarOptionals.ProviderId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TransactionId.IsSet() {
		localVarFormParams.Add("transactionId", parameterToString(localVarOptionals.TransactionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AccountNo.IsSet() {
		localVarFormParams.Add("accountNo", parameterToString(localVarOptionals.AccountNo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RppsBillerId.IsSet() {
		localVarFormParams.Add("rppsBillerId", parameterToString(localVarOptionals.RppsBillerId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BillerAccountNo.IsSet() {
		localVarFormParams.Add("billerAccountNo", parameterToString(localVarOptionals.BillerAccountNo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FrequencyType.IsSet() {
		localVarFormParams.Add("frequencyType", parameterToString(localVarOptionals.FrequencyType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NextDate.IsSet() {
		localVarFormParams.Add("nextDate", parameterToString(localVarOptionals.NextDate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EndDate.IsSet() {
		localVarFormParams.Add("endDate", parameterToString(localVarOptionals.EndDate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Amount.IsSet() {
		localVarFormParams.Add("amount", parameterToString(localVarOptionals.Amount.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v InlineResponseDefault12
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
TransactionsApiService Assess Fee
Use the Assess Fee endpoint to charge a fee to the specified account. The fee &#x60;type&#x60; parameter values must already be registered in the Galileo system for your program.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *TransactionsApiPostAssessfeeOpts - Optional Parameters:
     * @param "ApiLogin" (optional.String) - 
     * @param "ApiTransKey" (optional.String) - 
     * @param "ProviderId" (optional.Int32) - 
     * @param "TransactionId" (optional.String) - 
     * @param "AccountNo" (optional.String) - 
     * @param "Type_" (optional.String) - 
     * @param "TransAmount" (optional.Float32) - 
     * @param "Amount" (optional.Float32) - 
     * @param "VerifyOnly" (optional.Int32) - 
     * @param "ResponseContentType" (optional.String) -  Use &#x60;xml&#x60; or &#x60;json&#x60; to specify the type of response. The default value is &#x60;xml&#x60;. Use this instead of the standard &#x60;accept&#x60; header.
@return InlineResponseDefault97
*/

type TransactionsApiPostAssessfeeOpts struct {
    ApiLogin optional.String
    ApiTransKey optional.String
    ProviderId optional.Int32
    TransactionId optional.String
    AccountNo optional.String
    Type_ optional.String
    TransAmount optional.Float32
    Amount optional.Float32
    VerifyOnly optional.Int32
    ResponseContentType optional.String
}

func (a *TransactionsApiService) PostAssessfee(ctx context.Context, localVarOptionals *TransactionsApiPostAssessfeeOpts) (InlineResponseDefault97, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponseDefault97
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/assessFee"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ResponseContentType.IsSet() {
		localVarHeaderParams["response-content-type"] = parameterToString(localVarOptionals.ResponseContentType.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.ApiLogin.IsSet() {
		localVarFormParams.Add("apiLogin", parameterToString(localVarOptionals.ApiLogin.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ApiTransKey.IsSet() {
		localVarFormParams.Add("apiTransKey", parameterToString(localVarOptionals.ApiTransKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderId.IsSet() {
		localVarFormParams.Add("providerId", parameterToString(localVarOptionals.ProviderId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TransactionId.IsSet() {
		localVarFormParams.Add("transactionId", parameterToString(localVarOptionals.TransactionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AccountNo.IsSet() {
		localVarFormParams.Add("accountNo", parameterToString(localVarOptionals.AccountNo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarFormParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TransAmount.IsSet() {
		localVarFormParams.Add("transAmount", parameterToString(localVarOptionals.TransAmount.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Amount.IsSet() {
		localVarFormParams.Add("amount", parameterToString(localVarOptionals.Amount.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VerifyOnly.IsSet() {
		localVarFormParams.Add("verifyOnly", parameterToString(localVarOptionals.VerifyOnly.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v InlineResponseDefault97
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
TransactionsApiService Cancel ACH Transaction
Use the Cancel ACH Transaction endpoint to cancel a transaction that you created with the &lt;a href&#x3D;\&quot;ref:post_createachtransaction\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Create ACH Transaction&lt;/a&gt; endpoint. You cannot cancel the ACH transaction after the ACH binaries have processed it.  For more information on this endpoint see &lt;a href&#x3D;\&quot;doc:ach-endpoints#canceling-an-ach-transaction\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Canceling an ACH transaction&lt;/a&gt; in the *ACH Endpoints* guide.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *TransactionsApiPostCancelachtransactionOpts - Optional Parameters:
     * @param "ApiLogin" (optional.String) - 
     * @param "ApiTransKey" (optional.String) - 
     * @param "ProviderId" (optional.Int32) - 
     * @param "TransactionId" (optional.String) - 
     * @param "AccountNo" (optional.String) - 
     * @param "AchTransactionId" (optional.Int32) - 
     * @param "ResponseContentType" (optional.String) -  Use &#x60;xml&#x60; or &#x60;json&#x60; to specify the type of response. The default value is &#x60;xml&#x60;. Use this instead of the standard &#x60;accept&#x60; header.
@return InlineResponseDefault92
*/

type TransactionsApiPostCancelachtransactionOpts struct {
    ApiLogin optional.String
    ApiTransKey optional.String
    ProviderId optional.Int32
    TransactionId optional.String
    AccountNo optional.String
    AchTransactionId optional.Int32
    ResponseContentType optional.String
}

func (a *TransactionsApiService) PostCancelachtransaction(ctx context.Context, localVarOptionals *TransactionsApiPostCancelachtransactionOpts) (InlineResponseDefault92, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponseDefault92
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/cancelAchTransaction"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ResponseContentType.IsSet() {
		localVarHeaderParams["response-content-type"] = parameterToString(localVarOptionals.ResponseContentType.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.ApiLogin.IsSet() {
		localVarFormParams.Add("apiLogin", parameterToString(localVarOptionals.ApiLogin.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ApiTransKey.IsSet() {
		localVarFormParams.Add("apiTransKey", parameterToString(localVarOptionals.ApiTransKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderId.IsSet() {
		localVarFormParams.Add("providerId", parameterToString(localVarOptionals.ProviderId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TransactionId.IsSet() {
		localVarFormParams.Add("transactionId", parameterToString(localVarOptionals.TransactionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AccountNo.IsSet() {
		localVarFormParams.Add("accountNo", parameterToString(localVarOptionals.AccountNo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AchTransactionId.IsSet() {
		localVarFormParams.Add("achTransactionId", parameterToString(localVarOptionals.AchTransactionId.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v InlineResponseDefault92
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
TransactionsApiService Cancel Bill Payment
Use the Cancel Bill Payment endpoint to cancel a billpay transaction. You cannot cancel an electronic (&lt;&lt;glossary:RPPS&gt;&gt;) payment with this endpoint. You **can** cancel these types of transactions:  * Paper transactions in status &#x60;N&#x60;, &#x60;W&#x60; or &#x60;P&#x60;. If the transaction is in another status, the endpoint returns &#x60;status_code: 435-02&#x60;  * Non-recurring paper or electronic transactions that are scheduled for a future date  See &lt;a href&#x3D;\&quot;doc:managing-billpay-transactions\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Managing Billpay Transactions&lt;/a&gt; for instructions on using this endpoint.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *TransactionsApiPostCancelbillpaymentOpts - Optional Parameters:
     * @param "ApiLogin" (optional.String) - 
     * @param "ApiTransKey" (optional.String) - 
     * @param "ProviderId" (optional.Int32) - 
     * @param "TransactionId" (optional.String) - 
     * @param "AccountNo" (optional.String) - 
     * @param "BillpayTransactionId" (optional.Int32) - 
     * @param "ResponseContentType" (optional.String) -  Use &#x60;xml&#x60; or &#x60;json&#x60; to specify the type of response. The default value is &#x60;xml&#x60;. Use this instead of the standard &#x60;accept&#x60; header.
@return InlineResponseDefault13
*/

type TransactionsApiPostCancelbillpaymentOpts struct {
    ApiLogin optional.String
    ApiTransKey optional.String
    ProviderId optional.Int32
    TransactionId optional.String
    AccountNo optional.String
    BillpayTransactionId optional.Int32
    ResponseContentType optional.String
}

func (a *TransactionsApiService) PostCancelbillpayment(ctx context.Context, localVarOptionals *TransactionsApiPostCancelbillpaymentOpts) (InlineResponseDefault13, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponseDefault13
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/cancelBillPayment"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ResponseContentType.IsSet() {
		localVarHeaderParams["response-content-type"] = parameterToString(localVarOptionals.ResponseContentType.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.ApiLogin.IsSet() {
		localVarFormParams.Add("apiLogin", parameterToString(localVarOptionals.ApiLogin.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ApiTransKey.IsSet() {
		localVarFormParams.Add("apiTransKey", parameterToString(localVarOptionals.ApiTransKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderId.IsSet() {
		localVarFormParams.Add("providerId", parameterToString(localVarOptionals.ProviderId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TransactionId.IsSet() {
		localVarFormParams.Add("transactionId", parameterToString(localVarOptionals.TransactionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AccountNo.IsSet() {
		localVarFormParams.Add("accountNo", parameterToString(localVarOptionals.AccountNo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BillpayTransactionId.IsSet() {
		localVarFormParams.Add("billpayTransactionId", parameterToString(localVarOptionals.BillpayTransactionId.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v InlineResponseDefault13
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
TransactionsApiService Create Account Transfer
Use the Create Account Transfer endpoint to move funds between accounts in the same program. You can combine a fee with the payment or adjustment, depending on what transaction types you have set up with Galileo. The accounts can belong to the same customer or different customers. If the accounts are in different programs, verify that the program parameters permit transferring funds between the programs.  Pass the sending account in the &#x60;accountNo&#x60; parameter and the receiving account in the &#x60;transferToAccountNo&#x60; parameter. The receiving account should be in &#x60;status: N&#x60; (active) and the active flag set to &#x60;Y&#x60;.  To permit this endpoint to drive the sending account negative, set the ALWNB parameter on the sending product.  Consult the &lt;a href&#x3D;\&quot;doc:creating-an-internal-transfer\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Creating an Internal Transfer&lt;/a&gt; guide for instructions on using this endpoint.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *TransactionsApiPostCreateaccounttransferOpts - Optional Parameters:
     * @param "ApiLogin" (optional.String) - 
     * @param "ApiTransKey" (optional.String) - 
     * @param "ProviderId" (optional.Int32) - 
     * @param "TransactionId" (optional.String) - 
     * @param "AccountNo" (optional.String) - 
     * @param "Amount" (optional.Float32) - 
     * @param "TransferToAccountNo" (optional.String) - 
     * @param "Message" (optional.String) - 
     * @param "SenderMessage" (optional.String) - 
     * @param "Type_" (optional.String) - 
     * @param "ResponseContentType" (optional.String) -  Use &#x60;xml&#x60; or &#x60;json&#x60; to specify the type of response. The default value is &#x60;xml&#x60;. Use this instead of the standard &#x60;accept&#x60; header.
@return InlineResponseDefault25
*/

type TransactionsApiPostCreateaccounttransferOpts struct {
    ApiLogin optional.String
    ApiTransKey optional.String
    ProviderId optional.Int32
    TransactionId optional.String
    AccountNo optional.String
    Amount optional.Float32
    TransferToAccountNo optional.String
    Message optional.String
    SenderMessage optional.String
    Type_ optional.String
    ResponseContentType optional.String
}

func (a *TransactionsApiService) PostCreateaccounttransfer(ctx context.Context, localVarOptionals *TransactionsApiPostCreateaccounttransferOpts) (InlineResponseDefault25, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponseDefault25
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/createAccountTransfer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ResponseContentType.IsSet() {
		localVarHeaderParams["response-content-type"] = parameterToString(localVarOptionals.ResponseContentType.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.ApiLogin.IsSet() {
		localVarFormParams.Add("apiLogin", parameterToString(localVarOptionals.ApiLogin.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ApiTransKey.IsSet() {
		localVarFormParams.Add("apiTransKey", parameterToString(localVarOptionals.ApiTransKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderId.IsSet() {
		localVarFormParams.Add("providerId", parameterToString(localVarOptionals.ProviderId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TransactionId.IsSet() {
		localVarFormParams.Add("transactionId", parameterToString(localVarOptionals.TransactionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AccountNo.IsSet() {
		localVarFormParams.Add("accountNo", parameterToString(localVarOptionals.AccountNo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Amount.IsSet() {
		localVarFormParams.Add("amount", parameterToString(localVarOptionals.Amount.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TransferToAccountNo.IsSet() {
		localVarFormParams.Add("transferToAccountNo", parameterToString(localVarOptionals.TransferToAccountNo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Message.IsSet() {
		localVarFormParams.Add("message", parameterToString(localVarOptionals.Message.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SenderMessage.IsSet() {
		localVarFormParams.Add("senderMessage", parameterToString(localVarOptionals.SenderMessage.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarFormParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v InlineResponseDefault25
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
TransactionsApiService Create ACH Transaction
Use the Create ACH Transaction endpoint to originate an ACH transaction to move funds between a customer account (&#x60;accountNo&#x60;) and an existing ACH bank account (&#x60;achAccountId&#x60;). Use the &lt;a href&#x3D;\&quot;ref:post_addachaccount\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Add ACH Account&lt;/a&gt; endpoint to add an ACH bank account.  For more information on this endpoint see &lt;a href&#x3D;\&quot;doc:ach-endpoints#creating-an-ach-transaction\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Creating  an ACH transaction&lt;/a&gt; in the *ACH Endpoints* guide.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *TransactionsApiPostCreateachtransactionOpts - Optional Parameters:
     * @param "ApiLogin" (optional.String) - 
     * @param "ApiTransKey" (optional.String) - 
     * @param "ProviderId" (optional.Int32) - 
     * @param "TransactionId" (optional.String) - 
     * @param "AccountNo" (optional.String) - 
     * @param "AchAccountId" (optional.Int32) - 
     * @param "Amount" (optional.Float32) - 
     * @param "Description" (optional.String) - 
     * @param "DebitCreditIndicator" (optional.String) - 
     * @param "SameDay" (optional.String) - 
     * @param "IdentNumber" (optional.String) - 
     * @param "ProcessorToken" (optional.String) - 
     * @param "HoldDays" (optional.Int32) - 
     * @param "ResponseContentType" (optional.String) -  Use &#x60;xml&#x60; or &#x60;json&#x60; to specify the type of response. The default value is &#x60;xml&#x60;. Use this instead of the standard &#x60;accept&#x60; header.
@return InlineResponseDefault9
*/

type TransactionsApiPostCreateachtransactionOpts struct {
    ApiLogin optional.String
    ApiTransKey optional.String
    ProviderId optional.Int32
    TransactionId optional.String
    AccountNo optional.String
    AchAccountId optional.Int32
    Amount optional.Float32
    Description optional.String
    DebitCreditIndicator optional.String
    SameDay optional.String
    IdentNumber optional.String
    ProcessorToken optional.String
    HoldDays optional.Int32
    ResponseContentType optional.String
}

func (a *TransactionsApiService) PostCreateachtransaction(ctx context.Context, localVarOptionals *TransactionsApiPostCreateachtransactionOpts) (InlineResponseDefault9, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponseDefault9
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/createAchTransaction"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ResponseContentType.IsSet() {
		localVarHeaderParams["response-content-type"] = parameterToString(localVarOptionals.ResponseContentType.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.ApiLogin.IsSet() {
		localVarFormParams.Add("apiLogin", parameterToString(localVarOptionals.ApiLogin.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ApiTransKey.IsSet() {
		localVarFormParams.Add("apiTransKey", parameterToString(localVarOptionals.ApiTransKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderId.IsSet() {
		localVarFormParams.Add("providerId", parameterToString(localVarOptionals.ProviderId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TransactionId.IsSet() {
		localVarFormParams.Add("transactionId", parameterToString(localVarOptionals.TransactionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AccountNo.IsSet() {
		localVarFormParams.Add("accountNo", parameterToString(localVarOptionals.AccountNo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AchAccountId.IsSet() {
		localVarFormParams.Add("achAccountId", parameterToString(localVarOptionals.AchAccountId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Amount.IsSet() {
		localVarFormParams.Add("amount", parameterToString(localVarOptionals.Amount.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Description.IsSet() {
		localVarFormParams.Add("description", parameterToString(localVarOptionals.Description.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DebitCreditIndicator.IsSet() {
		localVarFormParams.Add("debitCreditIndicator", parameterToString(localVarOptionals.DebitCreditIndicator.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SameDay.IsSet() {
		localVarFormParams.Add("sameDay", parameterToString(localVarOptionals.SameDay.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IdentNumber.IsSet() {
		localVarFormParams.Add("identNumber", parameterToString(localVarOptionals.IdentNumber.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProcessorToken.IsSet() {
		localVarFormParams.Add("processorToken", parameterToString(localVarOptionals.ProcessorToken.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HoldDays.IsSet() {
		localVarFormParams.Add("holdDays", parameterToString(localVarOptionals.HoldDays.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v InlineResponseDefault9
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
TransactionsApiService Create Adjustment
Use the Create Adjustment endpoint to move funds into or out of a customer account. Transactions using this endpoint are returned by the &lt;a href&#x3D;\&quot;ref:post_getaccountoverview\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Get Account Overview&lt;/a&gt; endpoint only after several seconds have elapsed. To drive an account negative using this endpoint, set the ALWNB parameter at the *provider* level.  [block:callout]  { \&quot;type\&quot;: \&quot;warning\&quot;, \&quot;title\&quot;: \&quot;Warning\&quot;, \&quot;body\&quot;: \&quot;This endpoint requires a positive integer less than 9223372036854775807 (sys.maxint in Python 2 or sys.maxsize in Python 3) for &#x60;transactionId&#x60; rather than the alphanumeric string that all other endpoints use. The Reverse Adjustment endpoint uses this integer to identify the transaction to reverse out.\&quot; } [/block]  
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *TransactionsApiPostCreateadjustmentOpts - Optional Parameters:
     * @param "ApiLogin" (optional.String) - 
     * @param "ApiTransKey" (optional.String) - 
     * @param "ProviderId" (optional.Int32) - 
     * @param "TransactionId" (optional.Int64) - 
     * @param "AccountNo" (optional.String) - 
     * @param "Amount" (optional.Float32) - 
     * @param "Type_" (optional.String) - 
     * @param "Description" (optional.String) - 
     * @param "DebitCreditIndicator" (optional.String) - 
     * @param "Location" (optional.String) - 
     * @param "LocationType" (optional.Int32) - 
     * @param "VerifyOnly" (optional.String) - 
     * @param "IncludeRtfTransfer" (optional.String) - 
     * @param "DisputeId" (optional.String) - 
     * @param "ResponseContentType" (optional.String) -  Use &#x60;xml&#x60; or &#x60;json&#x60; to specify the type of response. The default value is &#x60;xml&#x60;. Use this instead of the standard &#x60;accept&#x60; header.
@return InlineResponseDefault99
*/

type TransactionsApiPostCreateadjustmentOpts struct {
    ApiLogin optional.String
    ApiTransKey optional.String
    ProviderId optional.Int32
    TransactionId optional.Int64
    AccountNo optional.String
    Amount optional.Float32
    Type_ optional.String
    Description optional.String
    DebitCreditIndicator optional.String
    Location optional.String
    LocationType optional.Int32
    VerifyOnly optional.String
    IncludeRtfTransfer optional.String
    DisputeId optional.String
    ResponseContentType optional.String
}

func (a *TransactionsApiService) PostCreateadjustment(ctx context.Context, localVarOptionals *TransactionsApiPostCreateadjustmentOpts) (InlineResponseDefault99, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponseDefault99
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/createAdjustment"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ResponseContentType.IsSet() {
		localVarHeaderParams["response-content-type"] = parameterToString(localVarOptionals.ResponseContentType.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.ApiLogin.IsSet() {
		localVarFormParams.Add("apiLogin", parameterToString(localVarOptionals.ApiLogin.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ApiTransKey.IsSet() {
		localVarFormParams.Add("apiTransKey", parameterToString(localVarOptionals.ApiTransKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderId.IsSet() {
		localVarFormParams.Add("providerId", parameterToString(localVarOptionals.ProviderId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TransactionId.IsSet() {
		localVarFormParams.Add("transactionId", parameterToString(localVarOptionals.TransactionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AccountNo.IsSet() {
		localVarFormParams.Add("accountNo", parameterToString(localVarOptionals.AccountNo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Amount.IsSet() {
		localVarFormParams.Add("amount", parameterToString(localVarOptionals.Amount.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarFormParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Description.IsSet() {
		localVarFormParams.Add("description", parameterToString(localVarOptionals.Description.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DebitCreditIndicator.IsSet() {
		localVarFormParams.Add("debitCreditIndicator", parameterToString(localVarOptionals.DebitCreditIndicator.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Location.IsSet() {
		localVarFormParams.Add("location", parameterToString(localVarOptionals.Location.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LocationType.IsSet() {
		localVarFormParams.Add("locationType", parameterToString(localVarOptionals.LocationType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VerifyOnly.IsSet() {
		localVarFormParams.Add("verifyOnly", parameterToString(localVarOptionals.VerifyOnly.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IncludeRtfTransfer.IsSet() {
		localVarFormParams.Add("includeRtfTransfer", parameterToString(localVarOptionals.IncludeRtfTransfer.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DisputeId.IsSet() {
		localVarFormParams.Add("disputeId", parameterToString(localVarOptionals.DisputeId.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v InlineResponseDefault99
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
TransactionsApiService Create Bill Payment
Use the Create Bill Payment endpoint to create a bill payment transaction. Before you can use this endpoint, you must create the biller.  See &lt;a href&#x3D;\&quot;doc:creating-a-billpay-transaction\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Creating a Billpay Transaction&lt;/a&gt; for instructions on using this endpoint.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *TransactionsApiPostCreatebillpaymentOpts - Optional Parameters:
     * @param "ApiLogin" (optional.String) - 
     * @param "ApiTransKey" (optional.String) - 
     * @param "ProviderId" (optional.Int32) - 
     * @param "TransactionId" (optional.String) - 
     * @param "AccountNo" (optional.String) - 
     * @param "Amount" (optional.Float32) - 
     * @param "BillerId" (optional.Int32) - 
     * @param "ProcessDate" (optional.String) - 
     * @param "Memo" (optional.String) - 
     * @param "ResponseContentType" (optional.String) -  Use &#x60;xml&#x60; or &#x60;json&#x60; to specify the type of response. The default value is &#x60;xml&#x60;. Use this instead of the standard &#x60;accept&#x60; header.
@return InlineResponseDefault14
*/

type TransactionsApiPostCreatebillpaymentOpts struct {
    ApiLogin optional.String
    ApiTransKey optional.String
    ProviderId optional.Int32
    TransactionId optional.String
    AccountNo optional.String
    Amount optional.Float32
    BillerId optional.Int32
    ProcessDate optional.String
    Memo optional.String
    ResponseContentType optional.String
}

func (a *TransactionsApiService) PostCreatebillpayment(ctx context.Context, localVarOptionals *TransactionsApiPostCreatebillpaymentOpts) (InlineResponseDefault14, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponseDefault14
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/createBillPayment"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ResponseContentType.IsSet() {
		localVarHeaderParams["response-content-type"] = parameterToString(localVarOptionals.ResponseContentType.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.ApiLogin.IsSet() {
		localVarFormParams.Add("apiLogin", parameterToString(localVarOptionals.ApiLogin.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ApiTransKey.IsSet() {
		localVarFormParams.Add("apiTransKey", parameterToString(localVarOptionals.ApiTransKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderId.IsSet() {
		localVarFormParams.Add("providerId", parameterToString(localVarOptionals.ProviderId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TransactionId.IsSet() {
		localVarFormParams.Add("transactionId", parameterToString(localVarOptionals.TransactionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AccountNo.IsSet() {
		localVarFormParams.Add("accountNo", parameterToString(localVarOptionals.AccountNo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Amount.IsSet() {
		localVarFormParams.Add("amount", parameterToString(localVarOptionals.Amount.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BillerId.IsSet() {
		localVarFormParams.Add("billerId", parameterToString(localVarOptionals.BillerId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProcessDate.IsSet() {
		localVarFormParams.Add("processDate", parameterToString(localVarOptionals.ProcessDate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Memo.IsSet() {
		localVarFormParams.Add("memo", parameterToString(localVarOptionals.Memo.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v InlineResponseDefault14
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
TransactionsApiService Create Hold
Use the Create Hold endpoint to create a hold (reserve) on an amount of funds for a specified payment, or to create a hold on an account in general. This endpoint supports remote deposit capture (RDC).  To create a hold on a specific payment you must pass &#x60;amount&#x60; and &#x60;pmtId&#x60;. The default hold limit is 1 000 000. You can override this limit with the MXHLD parameter.  To create a hold on an account, your program parameters (THOLD) must specify that an account hold is valid for the &#x60;holdType&#x60; parameter.  This endpoint does not create authorization holds on an account for card-association transactions &amp;mdash; such holds are created automatically when an authorization request is approved.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *TransactionsApiPostCreateholdOpts - Optional Parameters:
     * @param "ApiLogin" (optional.String) - 
     * @param "ApiTransKey" (optional.String) - 
     * @param "ProviderId" (optional.Int32) - 
     * @param "TransactionId" (optional.String) - 
     * @param "AccountNo" (optional.String) - 
     * @param "Amount" (optional.Float32) - 
     * @param "ExpirationDateTime" (optional.Time) - 
     * @param "PmtId" (optional.Int32) - 
     * @param "HoldType" (optional.String) - 
     * @param "Description" (optional.String) - 
     * @param "ExternalId" (optional.String) - 
     * @param "ResponseContentType" (optional.String) -  Use &#x60;xml&#x60; or &#x60;json&#x60; to specify the type of response. The default value is &#x60;xml&#x60;. Use this instead of the standard &#x60;accept&#x60; header.
@return InlineResponseDefault94
*/

type TransactionsApiPostCreateholdOpts struct {
    ApiLogin optional.String
    ApiTransKey optional.String
    ProviderId optional.Int32
    TransactionId optional.String
    AccountNo optional.String
    Amount optional.Float32
    ExpirationDateTime optional.Time
    PmtId optional.Int32
    HoldType optional.String
    Description optional.String
    ExternalId optional.String
    ResponseContentType optional.String
}

func (a *TransactionsApiService) PostCreatehold(ctx context.Context, localVarOptionals *TransactionsApiPostCreateholdOpts) (InlineResponseDefault94, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponseDefault94
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/createHold"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ResponseContentType.IsSet() {
		localVarHeaderParams["response-content-type"] = parameterToString(localVarOptionals.ResponseContentType.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.ApiLogin.IsSet() {
		localVarFormParams.Add("apiLogin", parameterToString(localVarOptionals.ApiLogin.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ApiTransKey.IsSet() {
		localVarFormParams.Add("apiTransKey", parameterToString(localVarOptionals.ApiTransKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderId.IsSet() {
		localVarFormParams.Add("providerId", parameterToString(localVarOptionals.ProviderId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TransactionId.IsSet() {
		localVarFormParams.Add("transactionId", parameterToString(localVarOptionals.TransactionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AccountNo.IsSet() {
		localVarFormParams.Add("accountNo", parameterToString(localVarOptionals.AccountNo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Amount.IsSet() {
		localVarFormParams.Add("amount", parameterToString(localVarOptionals.Amount.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ExpirationDateTime.IsSet() {
		localVarFormParams.Add("expirationDateTime", parameterToString(localVarOptionals.ExpirationDateTime.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PmtId.IsSet() {
		localVarFormParams.Add("pmtId", parameterToString(localVarOptionals.PmtId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HoldType.IsSet() {
		localVarFormParams.Add("holdType", parameterToString(localVarOptionals.HoldType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Description.IsSet() {
		localVarFormParams.Add("description", parameterToString(localVarOptionals.Description.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ExternalId.IsSet() {
		localVarFormParams.Add("externalId", parameterToString(localVarOptionals.ExternalId.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v InlineResponseDefault94
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
TransactionsApiService Create Payment
Use the Create Payment endpoint to move funds into a customer account. This endpoint may return load limit and velocity violations in its response. Payments created with this endpoint are returned by the &lt;a href&#x3D;\&quot;ref:post_getaccountoverview\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Get Account Overview&lt;/a&gt; endpoint only after several seconds have elapsed.  #### Load limit and velocity response If the payment violates load or velocity limits, this endpoint returns &#x60;status: 26&#x60; with &#x60;limit_error&#x60;, &#x60;limit_id&#x60;, and &#x60;limit_response_code&#x60; values. Use the &#x60;limit_id&#x60; for  troubleshooting the load and velocity configuration. The &#x60;limit_response_code&#x60; values are enumerated in the &lt;a href&#x3D;\&quot;ref:api-reference-limit-response-codes\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Limit Response Codes&lt;/a&gt; table.  Consult the &lt;a href&#x3D;\&quot;doc:creating-a-payment\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Creating a Payment&lt;/a&gt; guide for instructions on using this endpoint.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *TransactionsApiPostCreatepaymentOpts - Optional Parameters:
     * @param "ApiLogin" (optional.String) - 
     * @param "ApiTransKey" (optional.String) - 
     * @param "ProviderId" (optional.Int32) - 
     * @param "TransactionId" (optional.String) - 
     * @param "AccountNo" (optional.String) - 
     * @param "Amount" (optional.Float32) - 
     * @param "Type_" (optional.String) - 
     * @param "Description" (optional.String) - 
     * @param "Location" (optional.String) - 
     * @param "LocationType" (optional.Int32) - 
     * @param "ProviderAssessedFee" (optional.Float32) - 
     * @param "VerifyOnly" (optional.Int32) - 
     * @param "MerchantId" (optional.String) - 
     * @param "Partner" (optional.String) - 
     * @param "RetailChain" (optional.String) - 
     * @param "RetailSaleTransactionKey" (optional.String) - 
     * @param "StoreAddress1" (optional.String) - 
     * @param "StoreAddress2" (optional.String) - 
     * @param "StoreCounty" (optional.String) - 
     * @param "StoreLatitude" (optional.String) - 
     * @param "StoreLongitude" (optional.String) - 
     * @param "StoreName" (optional.String) - 
     * @param "StoreNumber" (optional.String) - 
     * @param "StoreTransactionDate" (optional.Time) - 
     * @param "StoreCity" (optional.String) - 
     * @param "StoreState" (optional.String) - 
     * @param "StoreZipCode" (optional.String) - 
     * @param "HoldAmount" (optional.Float32) - 
     * @param "HoldExpirationDateTime" (optional.Time) - 
     * @param "HoldDescription" (optional.String) - 
     * @param "HoldExternalId" (optional.String) - 
     * @param "ReferenceId" (optional.String) - 
     * @param "OriginatorName" (optional.String) - 
     * @param "ReceiverName" (optional.String) - 
     * @param "ResponseContentType" (optional.String) -  Use &#x60;xml&#x60; or &#x60;json&#x60; to specify the type of response. The default value is &#x60;xml&#x60;. Use this instead of the standard &#x60;accept&#x60; header.
@return InlineResponseDefault96
*/

type TransactionsApiPostCreatepaymentOpts struct {
    ApiLogin optional.String
    ApiTransKey optional.String
    ProviderId optional.Int32
    TransactionId optional.String
    AccountNo optional.String
    Amount optional.Float32
    Type_ optional.String
    Description optional.String
    Location optional.String
    LocationType optional.Int32
    ProviderAssessedFee optional.Float32
    VerifyOnly optional.Int32
    MerchantId optional.String
    Partner optional.String
    RetailChain optional.String
    RetailSaleTransactionKey optional.String
    StoreAddress1 optional.String
    StoreAddress2 optional.String
    StoreCounty optional.String
    StoreLatitude optional.String
    StoreLongitude optional.String
    StoreName optional.String
    StoreNumber optional.String
    StoreTransactionDate optional.Time
    StoreCity optional.String
    StoreState optional.String
    StoreZipCode optional.String
    HoldAmount optional.Float32
    HoldExpirationDateTime optional.Time
    HoldDescription optional.String
    HoldExternalId optional.String
    ReferenceId optional.String
    OriginatorName optional.String
    ReceiverName optional.String
    ResponseContentType optional.String
}

func (a *TransactionsApiService) PostCreatepayment(ctx context.Context, localVarOptionals *TransactionsApiPostCreatepaymentOpts) (InlineResponseDefault96, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponseDefault96
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/createPayment"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ResponseContentType.IsSet() {
		localVarHeaderParams["response-content-type"] = parameterToString(localVarOptionals.ResponseContentType.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.ApiLogin.IsSet() {
		localVarFormParams.Add("apiLogin", parameterToString(localVarOptionals.ApiLogin.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ApiTransKey.IsSet() {
		localVarFormParams.Add("apiTransKey", parameterToString(localVarOptionals.ApiTransKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderId.IsSet() {
		localVarFormParams.Add("providerId", parameterToString(localVarOptionals.ProviderId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TransactionId.IsSet() {
		localVarFormParams.Add("transactionId", parameterToString(localVarOptionals.TransactionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AccountNo.IsSet() {
		localVarFormParams.Add("accountNo", parameterToString(localVarOptionals.AccountNo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Amount.IsSet() {
		localVarFormParams.Add("amount", parameterToString(localVarOptionals.Amount.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarFormParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Description.IsSet() {
		localVarFormParams.Add("description", parameterToString(localVarOptionals.Description.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Location.IsSet() {
		localVarFormParams.Add("location", parameterToString(localVarOptionals.Location.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LocationType.IsSet() {
		localVarFormParams.Add("locationType", parameterToString(localVarOptionals.LocationType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderAssessedFee.IsSet() {
		localVarFormParams.Add("providerAssessedFee", parameterToString(localVarOptionals.ProviderAssessedFee.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VerifyOnly.IsSet() {
		localVarFormParams.Add("verifyOnly", parameterToString(localVarOptionals.VerifyOnly.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MerchantId.IsSet() {
		localVarFormParams.Add("merchantId", parameterToString(localVarOptionals.MerchantId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Partner.IsSet() {
		localVarFormParams.Add("partner", parameterToString(localVarOptionals.Partner.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RetailChain.IsSet() {
		localVarFormParams.Add("retailChain", parameterToString(localVarOptionals.RetailChain.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RetailSaleTransactionKey.IsSet() {
		localVarFormParams.Add("retailSaleTransactionKey", parameterToString(localVarOptionals.RetailSaleTransactionKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StoreAddress1.IsSet() {
		localVarFormParams.Add("storeAddress1", parameterToString(localVarOptionals.StoreAddress1.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StoreAddress2.IsSet() {
		localVarFormParams.Add("storeAddress2", parameterToString(localVarOptionals.StoreAddress2.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StoreCounty.IsSet() {
		localVarFormParams.Add("storeCounty", parameterToString(localVarOptionals.StoreCounty.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StoreLatitude.IsSet() {
		localVarFormParams.Add("storeLatitude", parameterToString(localVarOptionals.StoreLatitude.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StoreLongitude.IsSet() {
		localVarFormParams.Add("storeLongitude", parameterToString(localVarOptionals.StoreLongitude.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StoreName.IsSet() {
		localVarFormParams.Add("storeName", parameterToString(localVarOptionals.StoreName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StoreNumber.IsSet() {
		localVarFormParams.Add("storeNumber", parameterToString(localVarOptionals.StoreNumber.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StoreTransactionDate.IsSet() {
		localVarFormParams.Add("storeTransactionDate", parameterToString(localVarOptionals.StoreTransactionDate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StoreCity.IsSet() {
		localVarFormParams.Add("storeCity", parameterToString(localVarOptionals.StoreCity.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StoreState.IsSet() {
		localVarFormParams.Add("storeState", parameterToString(localVarOptionals.StoreState.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StoreZipCode.IsSet() {
		localVarFormParams.Add("storeZipCode", parameterToString(localVarOptionals.StoreZipCode.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HoldAmount.IsSet() {
		localVarFormParams.Add("holdAmount", parameterToString(localVarOptionals.HoldAmount.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HoldExpirationDateTime.IsSet() {
		localVarFormParams.Add("holdExpirationDateTime", parameterToString(localVarOptionals.HoldExpirationDateTime.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HoldDescription.IsSet() {
		localVarFormParams.Add("holdDescription", parameterToString(localVarOptionals.HoldDescription.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HoldExternalId.IsSet() {
		localVarFormParams.Add("holdExternalId", parameterToString(localVarOptionals.HoldExternalId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReferenceId.IsSet() {
		localVarFormParams.Add("referenceId", parameterToString(localVarOptionals.ReferenceId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OriginatorName.IsSet() {
		localVarFormParams.Add("originatorName", parameterToString(localVarOptionals.OriginatorName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReceiverName.IsSet() {
		localVarFormParams.Add("receiverName", parameterToString(localVarOptionals.ReceiverName.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v InlineResponseDefault96
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
TransactionsApiService Create Simulated Card Authorization
Use the Create Simulated Card Authorization endpoint to simulate a card authorization in the &lt;&lt;glossary:CV&gt;&gt; environment. This endpoint creates an non-settled card authorization for the customer account and returns a response code and its description with the authorization ID.  For instructions on using this endpoint see &lt;a href&#x3D;\&quot;doc:simulating-card-transactions\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Simulating Card Transactions&lt;/a&gt;.  To use the following input parameters you must make special arrangements with Galileo. * &#x60;settleAmount&#x60; * &#x60;settleCurrencyCode&#x60; * &#x60;cardBillingAmount&#x60; * &#x60;cardBillingCurrencyCode&#x60; * &#x60;mcc&#x60; * &#x60;originalAuthId&#x60; * &#x60;specialFunctions&#x60; * &#x60;posEntryMode&#x60; * &#x60;requesterId&#x60; * &#x60;walletId&#x60; * &#x60;latitudeAndLongitude&#x60; * &#x60;partialAmount&#x60; * &#x60;partialForeignAmount&#x60; * &#x60;cashbackAmount&#x60; * &#x60;cashAdvanceAmount&#x60; * &#x60;pin&#x60; * &#x60;transType&#x60;  [block:callout]  { \&quot;type\&quot;: \&quot;warning\&quot;, \&quot;title\&quot;: \&quot;Warning\&quot;, \&quot;body\&quot;: \&quot;Do not use this endpoint in &lt;&lt;glossary:Production&gt;&gt;.\&quot; } [/block]  
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *TransactionsApiPostCreatesimulatedcardauthOpts - Optional Parameters:
     * @param "ApiLogin" (optional.String) - 
     * @param "ApiTransKey" (optional.String) - 
     * @param "ProviderId" (optional.Int32) - 
     * @param "TransactionId" (optional.String) - 
     * @param "AccountNo" (optional.String) - 
     * @param "Amount" (optional.Float32) - 
     * @param "Association" (optional.String) - 
     * @param "MerchantName" (optional.String) - 
     * @param "AcquirerId" (optional.String) - 
     * @param "TerminalId" (optional.String) - 
     * @param "MerchantId" (optional.String) - 
     * @param "CurrencyCode" (optional.String) - 
     * @param "SettleAmount" (optional.Float32) - 
     * @param "SettleCurrencyCode" (optional.String) - 
     * @param "CardBillingAmount" (optional.Float32) - 
     * @param "CardBillingCurrencyCode" (optional.String) - 
     * @param "Mcc" (optional.String) - 
     * @param "OriginalAuthId" (optional.String) - 
     * @param "SpecialFunctions" (optional.String) - 
     * @param "PosEntryMode" (optional.String) - 
     * @param "RequesterId" (optional.String) - 
     * @param "WalletId" (optional.String) - 
     * @param "LatitudeAndLongitude" (optional.String) - 
     * @param "PartialAmount" (optional.Float32) - 
     * @param "PartialForeignAmount" (optional.Float32) - 
     * @param "CashbackAmount" (optional.Float32) - 
     * @param "CashAdvanceAmount" (optional.Float32) - 
     * @param "Pin" (optional.String) - 
     * @param "TransType" (optional.Int32) - 
     * @param "ResponseContentType" (optional.String) -  Use &#x60;xml&#x60; or &#x60;json&#x60; to specify the type of response. The default value is &#x60;xml&#x60;. Use this instead of the standard &#x60;accept&#x60; header.
@return InlineResponseDefault23
*/

type TransactionsApiPostCreatesimulatedcardauthOpts struct {
    ApiLogin optional.String
    ApiTransKey optional.String
    ProviderId optional.Int32
    TransactionId optional.String
    AccountNo optional.String
    Amount optional.Float32
    Association optional.String
    MerchantName optional.String
    AcquirerId optional.String
    TerminalId optional.String
    MerchantId optional.String
    CurrencyCode optional.String
    SettleAmount optional.Float32
    SettleCurrencyCode optional.String
    CardBillingAmount optional.Float32
    CardBillingCurrencyCode optional.String
    Mcc optional.String
    OriginalAuthId optional.String
    SpecialFunctions optional.String
    PosEntryMode optional.String
    RequesterId optional.String
    WalletId optional.String
    LatitudeAndLongitude optional.String
    PartialAmount optional.Float32
    PartialForeignAmount optional.Float32
    CashbackAmount optional.Float32
    CashAdvanceAmount optional.Float32
    Pin optional.String
    TransType optional.Int32
    ResponseContentType optional.String
}

func (a *TransactionsApiService) PostCreatesimulatedcardauth(ctx context.Context, localVarOptionals *TransactionsApiPostCreatesimulatedcardauthOpts) (InlineResponseDefault23, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponseDefault23
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/createSimulatedCardAuth"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ResponseContentType.IsSet() {
		localVarHeaderParams["response-content-type"] = parameterToString(localVarOptionals.ResponseContentType.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.ApiLogin.IsSet() {
		localVarFormParams.Add("apiLogin", parameterToString(localVarOptionals.ApiLogin.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ApiTransKey.IsSet() {
		localVarFormParams.Add("apiTransKey", parameterToString(localVarOptionals.ApiTransKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderId.IsSet() {
		localVarFormParams.Add("providerId", parameterToString(localVarOptionals.ProviderId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TransactionId.IsSet() {
		localVarFormParams.Add("transactionId", parameterToString(localVarOptionals.TransactionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AccountNo.IsSet() {
		localVarFormParams.Add("accountNo", parameterToString(localVarOptionals.AccountNo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Amount.IsSet() {
		localVarFormParams.Add("amount", parameterToString(localVarOptionals.Amount.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Association.IsSet() {
		localVarFormParams.Add("association", parameterToString(localVarOptionals.Association.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MerchantName.IsSet() {
		localVarFormParams.Add("merchantName", parameterToString(localVarOptionals.MerchantName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AcquirerId.IsSet() {
		localVarFormParams.Add("acquirerId", parameterToString(localVarOptionals.AcquirerId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TerminalId.IsSet() {
		localVarFormParams.Add("terminalId", parameterToString(localVarOptionals.TerminalId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MerchantId.IsSet() {
		localVarFormParams.Add("merchantId", parameterToString(localVarOptionals.MerchantId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CurrencyCode.IsSet() {
		localVarFormParams.Add("currencyCode", parameterToString(localVarOptionals.CurrencyCode.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SettleAmount.IsSet() {
		localVarFormParams.Add("settleAmount", parameterToString(localVarOptionals.SettleAmount.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SettleCurrencyCode.IsSet() {
		localVarFormParams.Add("settleCurrencyCode", parameterToString(localVarOptionals.SettleCurrencyCode.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CardBillingAmount.IsSet() {
		localVarFormParams.Add("cardBillingAmount", parameterToString(localVarOptionals.CardBillingAmount.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CardBillingCurrencyCode.IsSet() {
		localVarFormParams.Add("cardBillingCurrencyCode", parameterToString(localVarOptionals.CardBillingCurrencyCode.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Mcc.IsSet() {
		localVarFormParams.Add("mcc", parameterToString(localVarOptionals.Mcc.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OriginalAuthId.IsSet() {
		localVarFormParams.Add("originalAuthId", parameterToString(localVarOptionals.OriginalAuthId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SpecialFunctions.IsSet() {
		localVarFormParams.Add("specialFunctions", parameterToString(localVarOptionals.SpecialFunctions.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PosEntryMode.IsSet() {
		localVarFormParams.Add("posEntryMode", parameterToString(localVarOptionals.PosEntryMode.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RequesterId.IsSet() {
		localVarFormParams.Add("requesterId", parameterToString(localVarOptionals.RequesterId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WalletId.IsSet() {
		localVarFormParams.Add("walletId", parameterToString(localVarOptionals.WalletId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LatitudeAndLongitude.IsSet() {
		localVarFormParams.Add("latitudeAndLongitude", parameterToString(localVarOptionals.LatitudeAndLongitude.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PartialAmount.IsSet() {
		localVarFormParams.Add("partialAmount", parameterToString(localVarOptionals.PartialAmount.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PartialForeignAmount.IsSet() {
		localVarFormParams.Add("partialForeignAmount", parameterToString(localVarOptionals.PartialForeignAmount.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CashbackAmount.IsSet() {
		localVarFormParams.Add("cashbackAmount", parameterToString(localVarOptionals.CashbackAmount.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CashAdvanceAmount.IsSet() {
		localVarFormParams.Add("cashAdvanceAmount", parameterToString(localVarOptionals.CashAdvanceAmount.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Pin.IsSet() {
		localVarFormParams.Add("pin", parameterToString(localVarOptionals.Pin.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TransType.IsSet() {
		localVarFormParams.Add("transType", parameterToString(localVarOptionals.TransType.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v InlineResponseDefault23
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
TransactionsApiService Create Simulated Card Settlement
Use the Create Simulated Card Settlement endpoint to settle a simulated card authorization in the &lt;&lt;glossary:CV&gt;&gt; environment. First, create a simulated authorization using the &lt;a href&#x3D;\&quot;ref:post_createsimulatedcardauth\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Create Simulated Card Authorization&lt;/a&gt; endpoint, and then use this endpoint to settle it. You must pass either &#x60;authId&#x60; or &#x60;merchantName&#x60; from the simulated authorization.  For instructions on using this endpoint see &lt;a href&#x3D;\&quot;doc:simulating-card-transactions\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Simulating Card Transactions&lt;/a&gt;.  [block:callout]  { \&quot;type\&quot;: \&quot;warning\&quot;, \&quot;title\&quot;: \&quot;Warning\&quot;, \&quot;body\&quot;: \&quot;Do not use this endpoint in &lt;&lt;glossary:Production&gt;&gt;.\&quot; } [/block]  [block:callout]  { \&quot;type\&quot;: \&quot;info\&quot;, \&quot;title\&quot;: \&quot;Note\&quot;, \&quot;body\&quot;: \&quot;A simulated settlement will settle for only the amount of the card authorization &amp;mdash; you cannot simulate an up-charge in the CV environment. For example, if the authorization amount is $10.50 and the settlement specifies $15.50, the posted settlement will be $10.50.\&quot; } [/block]  
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *TransactionsApiPostCreatesimulatedcardsettleOpts - Optional Parameters:
     * @param "ApiLogin" (optional.String) - 
     * @param "ApiTransKey" (optional.String) - 
     * @param "ProviderId" (optional.Int32) - 
     * @param "TransactionId" (optional.String) - 
     * @param "AccountNo" (optional.String) - 
     * @param "Amount" (optional.Float32) - 
     * @param "Association" (optional.String) - 
     * @param "MerchantName" (optional.String) - 
     * @param "CurrencyCode" (optional.String) - 
     * @param "SettleAmount" (optional.Float32) - 
     * @param "SettleCurrencyCode" (optional.String) - 
     * @param "CardBillingAmount" (optional.Float32) - 
     * @param "CardBillingCurrencyCode" (optional.String) - 
     * @param "AuthId" (optional.String) - 
     * @param "ResponseContentType" (optional.String) -  Use &#x60;xml&#x60; or &#x60;json&#x60; to specify the type of response. The default value is &#x60;xml&#x60;. Use this instead of the standard &#x60;accept&#x60; header.
@return InlineResponseDefault24
*/

type TransactionsApiPostCreatesimulatedcardsettleOpts struct {
    ApiLogin optional.String
    ApiTransKey optional.String
    ProviderId optional.Int32
    TransactionId optional.String
    AccountNo optional.String
    Amount optional.Float32
    Association optional.String
    MerchantName optional.String
    CurrencyCode optional.String
    SettleAmount optional.Float32
    SettleCurrencyCode optional.String
    CardBillingAmount optional.Float32
    CardBillingCurrencyCode optional.String
    AuthId optional.String
    ResponseContentType optional.String
}

func (a *TransactionsApiService) PostCreatesimulatedcardsettle(ctx context.Context, localVarOptionals *TransactionsApiPostCreatesimulatedcardsettleOpts) (InlineResponseDefault24, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponseDefault24
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/createSimulatedCardSettle"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ResponseContentType.IsSet() {
		localVarHeaderParams["response-content-type"] = parameterToString(localVarOptionals.ResponseContentType.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.ApiLogin.IsSet() {
		localVarFormParams.Add("apiLogin", parameterToString(localVarOptionals.ApiLogin.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ApiTransKey.IsSet() {
		localVarFormParams.Add("apiTransKey", parameterToString(localVarOptionals.ApiTransKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderId.IsSet() {
		localVarFormParams.Add("providerId", parameterToString(localVarOptionals.ProviderId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TransactionId.IsSet() {
		localVarFormParams.Add("transactionId", parameterToString(localVarOptionals.TransactionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AccountNo.IsSet() {
		localVarFormParams.Add("accountNo", parameterToString(localVarOptionals.AccountNo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Amount.IsSet() {
		localVarFormParams.Add("amount", parameterToString(localVarOptionals.Amount.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Association.IsSet() {
		localVarFormParams.Add("association", parameterToString(localVarOptionals.Association.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MerchantName.IsSet() {
		localVarFormParams.Add("merchantName", parameterToString(localVarOptionals.MerchantName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CurrencyCode.IsSet() {
		localVarFormParams.Add("currencyCode", parameterToString(localVarOptionals.CurrencyCode.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SettleAmount.IsSet() {
		localVarFormParams.Add("settleAmount", parameterToString(localVarOptionals.SettleAmount.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SettleCurrencyCode.IsSet() {
		localVarFormParams.Add("settleCurrencyCode", parameterToString(localVarOptionals.SettleCurrencyCode.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CardBillingAmount.IsSet() {
		localVarFormParams.Add("cardBillingAmount", parameterToString(localVarOptionals.CardBillingAmount.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CardBillingCurrencyCode.IsSet() {
		localVarFormParams.Add("cardBillingCurrencyCode", parameterToString(localVarOptionals.CardBillingCurrencyCode.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AuthId.IsSet() {
		localVarFormParams.Add("authId", parameterToString(localVarOptionals.AuthId.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v InlineResponseDefault24
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
TransactionsApiService Expire Authorization
Use the Expire Authorization endpoint to expire an existing authorization hold on a customer account. The authorization must be in an acceptable status before it can be expired. This endpoint marks the authorization as expired in the Galileo system; the action is not communicated to the network.  Acceptable statuses are defined by each card network, as shown in this table:  | Network | Status | | --- | --- | | Mastercard | &#x60;A&#x60;,&#x60;C&#x60; | | Visa | &#x60;A&#x60; | | Star | &#x60;A&#x60;,&#x60;S&#x60; |
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *TransactionsApiPostExpireauthorizationOpts - Optional Parameters:
     * @param "ApiLogin" (optional.String) - 
     * @param "ApiTransKey" (optional.String) - 
     * @param "ProviderId" (optional.Int32) - 
     * @param "TransactionId" (optional.String) - 
     * @param "AccountNo" (optional.String) - 
     * @param "AuthId" (optional.Int32) - 
     * @param "ResponseContentType" (optional.String) -  Use &#x60;xml&#x60; or &#x60;json&#x60; to specify the type of response. The default value is &#x60;xml&#x60;. Use this instead of the standard &#x60;accept&#x60; header.
@return InlineResponseDefault16
*/

type TransactionsApiPostExpireauthorizationOpts struct {
    ApiLogin optional.String
    ApiTransKey optional.String
    ProviderId optional.Int32
    TransactionId optional.String
    AccountNo optional.String
    AuthId optional.Int32
    ResponseContentType optional.String
}

func (a *TransactionsApiService) PostExpireauthorization(ctx context.Context, localVarOptionals *TransactionsApiPostExpireauthorizationOpts) (InlineResponseDefault16, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponseDefault16
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/expireAuthorization"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ResponseContentType.IsSet() {
		localVarHeaderParams["response-content-type"] = parameterToString(localVarOptionals.ResponseContentType.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.ApiLogin.IsSet() {
		localVarFormParams.Add("apiLogin", parameterToString(localVarOptionals.ApiLogin.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ApiTransKey.IsSet() {
		localVarFormParams.Add("apiTransKey", parameterToString(localVarOptionals.ApiTransKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderId.IsSet() {
		localVarFormParams.Add("providerId", parameterToString(localVarOptionals.ProviderId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TransactionId.IsSet() {
		localVarFormParams.Add("transactionId", parameterToString(localVarOptionals.TransactionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AccountNo.IsSet() {
		localVarFormParams.Add("accountNo", parameterToString(localVarOptionals.AccountNo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AuthId.IsSet() {
		localVarFormParams.Add("authId", parameterToString(localVarOptionals.AuthId.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v InlineResponseDefault16
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
TransactionsApiService Expire Hold
Use the Expire Hold endpoint to expire a funds hold that was created with the &lt;a href&#x3D;\&quot;ref:post_createhold\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Create Hold&lt;/a&gt; endpoint. This endpoint does not expire any other kind of hold.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *TransactionsApiPostExpireholdOpts - Optional Parameters:
     * @param "ApiLogin" (optional.String) - 
     * @param "ApiTransKey" (optional.String) - 
     * @param "ProviderId" (optional.Int32) - 
     * @param "TransactionId" (optional.String) - 
     * @param "HoldId" (optional.Int32) - 
     * @param "ExpirationDateTime" (optional.Time) - 
     * @param "ResponseContentType" (optional.String) -  Use &#x60;xml&#x60; or &#x60;json&#x60; to specify the type of response. The default value is &#x60;xml&#x60;. Use this instead of the standard &#x60;accept&#x60; header.
@return InlineResponseDefault95
*/

type TransactionsApiPostExpireholdOpts struct {
    ApiLogin optional.String
    ApiTransKey optional.String
    ProviderId optional.Int32
    TransactionId optional.String
    HoldId optional.Int32
    ExpirationDateTime optional.Time
    ResponseContentType optional.String
}

func (a *TransactionsApiService) PostExpirehold(ctx context.Context, localVarOptionals *TransactionsApiPostExpireholdOpts) (InlineResponseDefault95, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponseDefault95
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/expireHold"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ResponseContentType.IsSet() {
		localVarHeaderParams["response-content-type"] = parameterToString(localVarOptionals.ResponseContentType.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.ApiLogin.IsSet() {
		localVarFormParams.Add("apiLogin", parameterToString(localVarOptionals.ApiLogin.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ApiTransKey.IsSet() {
		localVarFormParams.Add("apiTransKey", parameterToString(localVarOptionals.ApiTransKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderId.IsSet() {
		localVarFormParams.Add("providerId", parameterToString(localVarOptionals.ProviderId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TransactionId.IsSet() {
		localVarFormParams.Add("transactionId", parameterToString(localVarOptionals.TransactionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HoldId.IsSet() {
		localVarFormParams.Add("holdId", parameterToString(localVarOptionals.HoldId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ExpirationDateTime.IsSet() {
		localVarFormParams.Add("expirationDateTime", parameterToString(localVarOptionals.ExpirationDateTime.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v InlineResponseDefault95
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
TransactionsApiService Get Account Overview
Use the Get Account Overview endpoint to retrieve the combined response data from several other endpoints. Best practice is to use this endpoint to retrieve the data for a customer&#x27;s landing page or other similar display.  Data sets returned by Get Account Overview: * General account information (balance, status, application date) * Cardholder profile data * Posted transactions * Pending card authorizations * Pending fees (generally because of insufficient funds) * Savings interest data, applicable only if an associated savings account exists; otherwise, a unary &#x60;savings_interest&#x60; element is returned.  [block:callout]  { \&quot;type\&quot;: \&quot;info\&quot;, \&quot;title\&quot;: \&quot;Note\&quot;, \&quot;body\&quot;: \&quot;Transactions created by the &lt;a href&#x3D;\\\&quot;ref:post_createpayment\\\&quot; target&#x3D;\\\&quot;_blank\\\&quot;&gt;Create Payment&lt;/a&gt; and &lt;a href&#x3D;\\\&quot;ref:post_createadjustment\\\&quot; target&#x3D;\\\&quot;_blank\\\&quot;&gt;Create Adjustment&lt;/a&gt; endpoints are not visible for several seconds after creation.\&quot; } [/block]  
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *TransactionsApiPostGetaccountoverviewOpts - Optional Parameters:
     * @param "ApiLogin" (optional.String) - 
     * @param "ApiTransKey" (optional.String) - 
     * @param "ProviderId" (optional.Int32) - 
     * @param "TransactionId" (optional.String) - 
     * @param "AccountNo" (optional.String) - 
     * @param "StartDate" (optional.String) - 
     * @param "EndDate" (optional.String) - 
     * @param "ResponseContentType" (optional.String) -  Use &#x60;xml&#x60; or &#x60;json&#x60; to specify the type of response. The default value is &#x60;xml&#x60;. Use this instead of the standard &#x60;accept&#x60; header.
@return InlineResponseDefault3
*/

type TransactionsApiPostGetaccountoverviewOpts struct {
    ApiLogin optional.String
    ApiTransKey optional.String
    ProviderId optional.Int32
    TransactionId optional.String
    AccountNo optional.String
    StartDate optional.String
    EndDate optional.String
    ResponseContentType optional.String
}

func (a *TransactionsApiService) PostGetaccountoverview(ctx context.Context, localVarOptionals *TransactionsApiPostGetaccountoverviewOpts) (InlineResponseDefault3, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponseDefault3
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/getAccountOverview"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ResponseContentType.IsSet() {
		localVarHeaderParams["response-content-type"] = parameterToString(localVarOptionals.ResponseContentType.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.ApiLogin.IsSet() {
		localVarFormParams.Add("apiLogin", parameterToString(localVarOptionals.ApiLogin.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ApiTransKey.IsSet() {
		localVarFormParams.Add("apiTransKey", parameterToString(localVarOptionals.ApiTransKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderId.IsSet() {
		localVarFormParams.Add("providerId", parameterToString(localVarOptionals.ProviderId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TransactionId.IsSet() {
		localVarFormParams.Add("transactionId", parameterToString(localVarOptionals.TransactionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AccountNo.IsSet() {
		localVarFormParams.Add("accountNo", parameterToString(localVarOptionals.AccountNo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StartDate.IsSet() {
		localVarFormParams.Add("startDate", parameterToString(localVarOptionals.StartDate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EndDate.IsSet() {
		localVarFormParams.Add("endDate", parameterToString(localVarOptionals.EndDate.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v InlineResponseDefault3
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
TransactionsApiService Get ACH Accounts
Use the Get ACH Accounts endpoint to retrieve a record of ACH accounts that are linked to a customer account.  For instructions on using this endpoint see &lt;a href&#x3D;\&quot;doc:ach-endpoints#viewing-ach-accounts\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Viewing ACH accounts&lt;/a&gt; in the *ACH Endpoints* guide.  [block:callout]  { \&quot;type\&quot;: \&quot;warn\&quot;, \&quot;title\&quot;: \&quot;Warning\&quot;, \&quot;body\&quot;: \&quot;If you plan to display ACH account and routing numbers to customers, be aware that the &#x60;accountNo&#x60; and &#x60;routingNo&#x60; returned by this endpoint may be tokenized if an aggregator service (such as Plaid) is used. Only display these values to customers if you are sure they will not be tokenized.\&quot; } [/block]  
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *TransactionsApiPostGetachaccountsOpts - Optional Parameters:
     * @param "ApiLogin" (optional.String) - 
     * @param "ApiTransKey" (optional.String) - 
     * @param "ProviderId" (optional.Int32) - 
     * @param "TransactionId" (optional.String) - 
     * @param "AccountNo" (optional.String) - 
     * @param "ResponseContentType" (optional.String) -  Use &#x60;xml&#x60; or &#x60;json&#x60; to specify the type of response. The default value is &#x60;xml&#x60;. Use this instead of the standard &#x60;accept&#x60; header.
@return InlineResponseDefault88
*/

type TransactionsApiPostGetachaccountsOpts struct {
    ApiLogin optional.String
    ApiTransKey optional.String
    ProviderId optional.Int32
    TransactionId optional.String
    AccountNo optional.String
    ResponseContentType optional.String
}

func (a *TransactionsApiService) PostGetachaccounts(ctx context.Context, localVarOptionals *TransactionsApiPostGetachaccountsOpts) (InlineResponseDefault88, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponseDefault88
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/getAchAccounts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ResponseContentType.IsSet() {
		localVarHeaderParams["response-content-type"] = parameterToString(localVarOptionals.ResponseContentType.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.ApiLogin.IsSet() {
		localVarFormParams.Add("apiLogin", parameterToString(localVarOptionals.ApiLogin.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ApiTransKey.IsSet() {
		localVarFormParams.Add("apiTransKey", parameterToString(localVarOptionals.ApiTransKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderId.IsSet() {
		localVarFormParams.Add("providerId", parameterToString(localVarOptionals.ProviderId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TransactionId.IsSet() {
		localVarFormParams.Add("transactionId", parameterToString(localVarOptionals.TransactionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AccountNo.IsSet() {
		localVarFormParams.Add("accountNo", parameterToString(localVarOptionals.AccountNo.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v InlineResponseDefault88
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
TransactionsApiService Get ACH Transaction History
Use the Get ACH Transaction History endpoint to retrieve the ACH transfer history for the specified customer account.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *TransactionsApiPostGetachtranshistoryOpts - Optional Parameters:
     * @param "ApiLogin" (optional.String) - 
     * @param "ApiTransKey" (optional.String) - 
     * @param "ProviderId" (optional.Int32) - 
     * @param "TransactionId" (optional.String) - 
     * @param "AccountNo" (optional.String) - 
     * @param "StartDate" (optional.String) - 
     * @param "EndDate" (optional.String) - 
     * @param "IncludeRelated" (optional.Int32) - 
     * @param "RecordCnt" (optional.Int32) - 
     * @param "ResponseContentType" (optional.String) -  Use &#x60;xml&#x60; or &#x60;json&#x60; to specify the type of response. The default value is &#x60;xml&#x60;. Use this instead of the standard &#x60;accept&#x60; header.
@return InlineResponseDefault93
*/

type TransactionsApiPostGetachtranshistoryOpts struct {
    ApiLogin optional.String
    ApiTransKey optional.String
    ProviderId optional.Int32
    TransactionId optional.String
    AccountNo optional.String
    StartDate optional.String
    EndDate optional.String
    IncludeRelated optional.Int32
    RecordCnt optional.Int32
    ResponseContentType optional.String
}

func (a *TransactionsApiService) PostGetachtranshistory(ctx context.Context, localVarOptionals *TransactionsApiPostGetachtranshistoryOpts) (InlineResponseDefault93, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponseDefault93
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/getAchTransHistory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ResponseContentType.IsSet() {
		localVarHeaderParams["response-content-type"] = parameterToString(localVarOptionals.ResponseContentType.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.ApiLogin.IsSet() {
		localVarFormParams.Add("apiLogin", parameterToString(localVarOptionals.ApiLogin.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ApiTransKey.IsSet() {
		localVarFormParams.Add("apiTransKey", parameterToString(localVarOptionals.ApiTransKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderId.IsSet() {
		localVarFormParams.Add("providerId", parameterToString(localVarOptionals.ProviderId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TransactionId.IsSet() {
		localVarFormParams.Add("transactionId", parameterToString(localVarOptionals.TransactionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AccountNo.IsSet() {
		localVarFormParams.Add("accountNo", parameterToString(localVarOptionals.AccountNo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StartDate.IsSet() {
		localVarFormParams.Add("startDate", parameterToString(localVarOptionals.StartDate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EndDate.IsSet() {
		localVarFormParams.Add("endDate", parameterToString(localVarOptionals.EndDate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IncludeRelated.IsSet() {
		localVarFormParams.Add("includeRelated", parameterToString(localVarOptionals.IncludeRelated.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RecordCnt.IsSet() {
		localVarFormParams.Add("recordCnt", parameterToString(localVarOptionals.RecordCnt.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v InlineResponseDefault93
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
TransactionsApiService Get All Transaction History
Use the Get All Transaction History endpoint to combine the results of the &lt;a href&#x3D;\&quot;ref:post_gettranshistory\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Get Transaction History&lt;/a&gt; and &lt;a href&#x3D;\&quot;ref:post_getauthhistory\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Get Authorization History&lt;/a&gt; endpoints. The running balance is calculated per transaction record. This endpoint returns the same data as the *All Transactions* page in the Galileo &lt;&lt;glossary:CST&gt;&gt;.  See &lt;a href&#x3D;\&quot;ref:record-set-paging\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Record-Set Pagination&lt;/a&gt; for instructions on using the paging parameters.  Open the Recipes below to see response examples.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *TransactionsApiPostGetalltranshistoryOpts - Optional Parameters:
     * @param "ApiLogin" (optional.String) - 
     * @param "ApiTransKey" (optional.String) - 
     * @param "ProviderId" (optional.Int32) - 
     * @param "TransactionId" (optional.String) - 
     * @param "AccountNo" (optional.String) - 
     * @param "StartDate" (optional.String) - 
     * @param "EndDate" (optional.String) - 
     * @param "Page" (optional.Int32) - 
     * @param "RecordCnt" (optional.Int32) - 
     * @param "ResponseContentType" (optional.String) -  Use &#x60;xml&#x60; or &#x60;json&#x60; to specify the type of response. The default value is &#x60;xml&#x60;. Use this instead of the standard &#x60;accept&#x60; header.
@return InlineResponseDefault27
*/

type TransactionsApiPostGetalltranshistoryOpts struct {
    ApiLogin optional.String
    ApiTransKey optional.String
    ProviderId optional.Int32
    TransactionId optional.String
    AccountNo optional.String
    StartDate optional.String
    EndDate optional.String
    Page optional.Int32
    RecordCnt optional.Int32
    ResponseContentType optional.String
}

func (a *TransactionsApiService) PostGetalltranshistory(ctx context.Context, localVarOptionals *TransactionsApiPostGetalltranshistoryOpts) (InlineResponseDefault27, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponseDefault27
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/getAllTransHistory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ResponseContentType.IsSet() {
		localVarHeaderParams["response-content-type"] = parameterToString(localVarOptionals.ResponseContentType.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.ApiLogin.IsSet() {
		localVarFormParams.Add("apiLogin", parameterToString(localVarOptionals.ApiLogin.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ApiTransKey.IsSet() {
		localVarFormParams.Add("apiTransKey", parameterToString(localVarOptionals.ApiTransKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderId.IsSet() {
		localVarFormParams.Add("providerId", parameterToString(localVarOptionals.ProviderId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TransactionId.IsSet() {
		localVarFormParams.Add("transactionId", parameterToString(localVarOptionals.TransactionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AccountNo.IsSet() {
		localVarFormParams.Add("accountNo", parameterToString(localVarOptionals.AccountNo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StartDate.IsSet() {
		localVarFormParams.Add("startDate", parameterToString(localVarOptionals.StartDate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EndDate.IsSet() {
		localVarFormParams.Add("endDate", parameterToString(localVarOptionals.EndDate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Page.IsSet() {
		localVarFormParams.Add("page", parameterToString(localVarOptionals.Page.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RecordCnt.IsSet() {
		localVarFormParams.Add("recordCnt", parameterToString(localVarOptionals.RecordCnt.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v InlineResponseDefault27
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
TransactionsApiService Get Authorization History
Use the Get Authorization History endpoint to retrieve a list of unsettled authorization transactions for an account during a specified period.  See &lt;a href&#x3D;\&quot;ref:record-set-paging\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Record-Set Pagination&lt;/a&gt; for instructions on using the paging parameters.  Open the Recipe below to see a response example.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *TransactionsApiPostGetauthhistoryOpts - Optional Parameters:
     * @param "ApiLogin" (optional.String) - 
     * @param "ApiTransKey" (optional.String) - 
     * @param "ProviderId" (optional.Int32) - 
     * @param "TransactionId" (optional.String) - 
     * @param "AccountNo" (optional.String) - 
     * @param "StartDate" (optional.String) - 
     * @param "EndDate" (optional.String) - 
     * @param "RecordCnt" (optional.Int32) - 
     * @param "IncludeRelated" (optional.Bool) - 
     * @param "ResponseContentType" (optional.String) -  Use &#x60;xml&#x60; or &#x60;json&#x60; to specify the type of response. The default value is &#x60;xml&#x60;. Use this instead of the standard &#x60;accept&#x60; header.
@return InlineResponseDefault2
*/

type TransactionsApiPostGetauthhistoryOpts struct {
    ApiLogin optional.String
    ApiTransKey optional.String
    ProviderId optional.Int32
    TransactionId optional.String
    AccountNo optional.String
    StartDate optional.String
    EndDate optional.String
    RecordCnt optional.Int32
    IncludeRelated optional.Bool
    ResponseContentType optional.String
}

func (a *TransactionsApiService) PostGetauthhistory(ctx context.Context, localVarOptionals *TransactionsApiPostGetauthhistoryOpts) (InlineResponseDefault2, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponseDefault2
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/getAuthHistory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ResponseContentType.IsSet() {
		localVarHeaderParams["response-content-type"] = parameterToString(localVarOptionals.ResponseContentType.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.ApiLogin.IsSet() {
		localVarFormParams.Add("apiLogin", parameterToString(localVarOptionals.ApiLogin.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ApiTransKey.IsSet() {
		localVarFormParams.Add("apiTransKey", parameterToString(localVarOptionals.ApiTransKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderId.IsSet() {
		localVarFormParams.Add("providerId", parameterToString(localVarOptionals.ProviderId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TransactionId.IsSet() {
		localVarFormParams.Add("transactionId", parameterToString(localVarOptionals.TransactionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AccountNo.IsSet() {
		localVarFormParams.Add("accountNo", parameterToString(localVarOptionals.AccountNo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StartDate.IsSet() {
		localVarFormParams.Add("startDate", parameterToString(localVarOptionals.StartDate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EndDate.IsSet() {
		localVarFormParams.Add("endDate", parameterToString(localVarOptionals.EndDate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RecordCnt.IsSet() {
		localVarFormParams.Add("recordCnt", parameterToString(localVarOptionals.RecordCnt.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IncludeRelated.IsSet() {
		localVarFormParams.Add("includeRelated", parameterToString(localVarOptionals.IncludeRelated.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v InlineResponseDefault2
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
TransactionsApiService Get Billers
Use the Get Billers endpoint to retrieve the billers for the specified customer account.  See &lt;a href&#x3D;\&quot;doc:creating-a-billpay-transaction\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Creating a Billpay Transaction&lt;/a&gt; for instructions on using this endpoint.  See &lt;a href&#x3D;\&quot;ref:record-set-paging\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Record-Set Pagination&lt;/a&gt; for instructions on using the paging parameters.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *TransactionsApiPostGetbillersOpts - Optional Parameters:
     * @param "ApiLogin" (optional.String) - 
     * @param "ApiTransKey" (optional.String) - 
     * @param "ProviderId" (optional.Int32) - 
     * @param "TransactionId" (optional.String) - 
     * @param "AccountNo" (optional.String) - 
     * @param "RecordCnt" (optional.Int32) - 
     * @param "Page" (optional.Int32) - 
     * @param "ResponseContentType" (optional.String) -  Use &#x60;xml&#x60; or &#x60;json&#x60; to specify the type of response. The default value is &#x60;xml&#x60;. Use this instead of the standard &#x60;accept&#x60; header.
@return InlineResponseDefault15
*/

type TransactionsApiPostGetbillersOpts struct {
    ApiLogin optional.String
    ApiTransKey optional.String
    ProviderId optional.Int32
    TransactionId optional.String
    AccountNo optional.String
    RecordCnt optional.Int32
    Page optional.Int32
    ResponseContentType optional.String
}

func (a *TransactionsApiService) PostGetbillers(ctx context.Context, localVarOptionals *TransactionsApiPostGetbillersOpts) (InlineResponseDefault15, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponseDefault15
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/getBillers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ResponseContentType.IsSet() {
		localVarHeaderParams["response-content-type"] = parameterToString(localVarOptionals.ResponseContentType.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.ApiLogin.IsSet() {
		localVarFormParams.Add("apiLogin", parameterToString(localVarOptionals.ApiLogin.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ApiTransKey.IsSet() {
		localVarFormParams.Add("apiTransKey", parameterToString(localVarOptionals.ApiTransKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderId.IsSet() {
		localVarFormParams.Add("providerId", parameterToString(localVarOptionals.ProviderId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TransactionId.IsSet() {
		localVarFormParams.Add("transactionId", parameterToString(localVarOptionals.TransactionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AccountNo.IsSet() {
		localVarFormParams.Add("accountNo", parameterToString(localVarOptionals.AccountNo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RecordCnt.IsSet() {
		localVarFormParams.Add("recordCnt", parameterToString(localVarOptionals.RecordCnt.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Page.IsSet() {
		localVarFormParams.Add("page", parameterToString(localVarOptionals.Page.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v InlineResponseDefault15
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
TransactionsApiService Get Bill Payment History
Use the Get Bill Payment History endpoint to retrieve bill payment transactions between the specified dates, including scheduled transactions. You can get the history for the specified account or for all related accounts.  See &lt;a href&#x3D;\&quot;doc:managing-billpay-transactions\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Managing Billpay Transactions&lt;/a&gt; for instructions on using this endpoint.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *TransactionsApiPostGetbillpayhistoryOpts - Optional Parameters:
     * @param "ApiLogin" (optional.String) - 
     * @param "ApiTransKey" (optional.String) - 
     * @param "ProviderId" (optional.Int32) - 
     * @param "TransactionId" (optional.String) - 
     * @param "AccountNo" (optional.String) - 
     * @param "StartDate" (optional.String) - 
     * @param "EndDate" (optional.String) - 
     * @param "IncludeRelated" (optional.Int32) - 
     * @param "RecordCnt" (optional.Int32) - 
     * @param "ResponseContentType" (optional.String) -  Use &#x60;xml&#x60; or &#x60;json&#x60; to specify the type of response. The default value is &#x60;xml&#x60;. Use this instead of the standard &#x60;accept&#x60; header.
@return InlineResponseDefault17
*/

type TransactionsApiPostGetbillpayhistoryOpts struct {
    ApiLogin optional.String
    ApiTransKey optional.String
    ProviderId optional.Int32
    TransactionId optional.String
    AccountNo optional.String
    StartDate optional.String
    EndDate optional.String
    IncludeRelated optional.Int32
    RecordCnt optional.Int32
    ResponseContentType optional.String
}

func (a *TransactionsApiService) PostGetbillpayhistory(ctx context.Context, localVarOptionals *TransactionsApiPostGetbillpayhistoryOpts) (InlineResponseDefault17, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponseDefault17
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/getBillPayHistory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ResponseContentType.IsSet() {
		localVarHeaderParams["response-content-type"] = parameterToString(localVarOptionals.ResponseContentType.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.ApiLogin.IsSet() {
		localVarFormParams.Add("apiLogin", parameterToString(localVarOptionals.ApiLogin.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ApiTransKey.IsSet() {
		localVarFormParams.Add("apiTransKey", parameterToString(localVarOptionals.ApiTransKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderId.IsSet() {
		localVarFormParams.Add("providerId", parameterToString(localVarOptionals.ProviderId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TransactionId.IsSet() {
		localVarFormParams.Add("transactionId", parameterToString(localVarOptionals.TransactionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AccountNo.IsSet() {
		localVarFormParams.Add("accountNo", parameterToString(localVarOptionals.AccountNo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StartDate.IsSet() {
		localVarFormParams.Add("startDate", parameterToString(localVarOptionals.StartDate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EndDate.IsSet() {
		localVarFormParams.Add("endDate", parameterToString(localVarOptionals.EndDate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IncludeRelated.IsSet() {
		localVarFormParams.Add("includeRelated", parameterToString(localVarOptionals.IncludeRelated.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RecordCnt.IsSet() {
		localVarFormParams.Add("recordCnt", parameterToString(localVarOptionals.RecordCnt.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v InlineResponseDefault17
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
TransactionsApiService Get Deposit History
Use the Get Deposit History endpoint to retrieve deposit history for either your entire program or for a specified customer. Omit the &#x60;accountNo&#x60; parameter to get the history for your entire program.  See &lt;a href&#x3D;\&quot;ref:record-set-paging\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Record-Set Pagination&lt;/a&gt; for instructions on using the paging parameters.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *TransactionsApiPostGetdeposithistoryOpts - Optional Parameters:
     * @param "ApiLogin" (optional.String) - 
     * @param "ApiTransKey" (optional.String) - 
     * @param "ProviderId" (optional.Int32) - 
     * @param "TransactionId" (optional.String) - 
     * @param "AccountNo" (optional.String) - 
     * @param "StartDate" (optional.String) - 
     * @param "EndDate" (optional.String) - 
     * @param "RecordCnt" (optional.Int32) - 
     * @param "Page" (optional.Int32) - 
     * @param "ResponseContentType" (optional.String) -  Use &#x60;xml&#x60; or &#x60;json&#x60; to specify the type of response. The default value is &#x60;xml&#x60;. Use this instead of the standard &#x60;accept&#x60; header.
@return InlineResponseDefault26
*/

type TransactionsApiPostGetdeposithistoryOpts struct {
    ApiLogin optional.String
    ApiTransKey optional.String
    ProviderId optional.Int32
    TransactionId optional.String
    AccountNo optional.String
    StartDate optional.String
    EndDate optional.String
    RecordCnt optional.Int32
    Page optional.Int32
    ResponseContentType optional.String
}

func (a *TransactionsApiService) PostGetdeposithistory(ctx context.Context, localVarOptionals *TransactionsApiPostGetdeposithistoryOpts) (InlineResponseDefault26, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponseDefault26
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/getDepositHistory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ResponseContentType.IsSet() {
		localVarHeaderParams["response-content-type"] = parameterToString(localVarOptionals.ResponseContentType.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.ApiLogin.IsSet() {
		localVarFormParams.Add("apiLogin", parameterToString(localVarOptionals.ApiLogin.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ApiTransKey.IsSet() {
		localVarFormParams.Add("apiTransKey", parameterToString(localVarOptionals.ApiTransKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderId.IsSet() {
		localVarFormParams.Add("providerId", parameterToString(localVarOptionals.ProviderId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TransactionId.IsSet() {
		localVarFormParams.Add("transactionId", parameterToString(localVarOptionals.TransactionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AccountNo.IsSet() {
		localVarFormParams.Add("accountNo", parameterToString(localVarOptionals.AccountNo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StartDate.IsSet() {
		localVarFormParams.Add("startDate", parameterToString(localVarOptionals.StartDate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EndDate.IsSet() {
		localVarFormParams.Add("endDate", parameterToString(localVarOptionals.EndDate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RecordCnt.IsSet() {
		localVarFormParams.Add("recordCnt", parameterToString(localVarOptionals.RecordCnt.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Page.IsSet() {
		localVarFormParams.Add("page", parameterToString(localVarOptionals.Page.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v InlineResponseDefault26
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
TransactionsApiService Get Direct Deposit Switch Token
Use the Get Direct Deposit Switch Token endpoint to request a &#x60;token&#x60; from Galileo to pass to the direct deposit switch provider&#x27;s SDK. 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *TransactionsApiPostGetdirectdepositswitchtokenOpts - Optional Parameters:
     * @param "ApiLogin" (optional.String) - 
     * @param "ApiTransKey" (optional.String) - 
     * @param "ProviderId" (optional.Int32) - 
     * @param "TransactionId" (optional.String) - 
     * @param "AccountNo" (optional.String) - 
     * @param "DdAccountNo" (optional.String) - 
     * @param "DdRoutingNo" (optional.String) - 
     * @param "DdAccountType" (optional.String) - 
     * @param "DdAccountDescription" (optional.String) - 
     * @param "ResponseContentType" (optional.String) -  Use &#x60;xml&#x60; or &#x60;json&#x60; to specify the type of response. The default value is &#x60;xml&#x60;. Use this instead of the standard &#x60;accept&#x60; header.
@return InlineResponseDefault114
*/

type TransactionsApiPostGetdirectdepositswitchtokenOpts struct {
    ApiLogin optional.String
    ApiTransKey optional.String
    ProviderId optional.Int32
    TransactionId optional.String
    AccountNo optional.String
    DdAccountNo optional.String
    DdRoutingNo optional.String
    DdAccountType optional.String
    DdAccountDescription optional.String
    ResponseContentType optional.String
}

func (a *TransactionsApiService) PostGetdirectdepositswitchtoken(ctx context.Context, localVarOptionals *TransactionsApiPostGetdirectdepositswitchtokenOpts) (InlineResponseDefault114, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponseDefault114
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/getDirectDepositSwitchToken"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ResponseContentType.IsSet() {
		localVarHeaderParams["response-content-type"] = parameterToString(localVarOptionals.ResponseContentType.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.ApiLogin.IsSet() {
		localVarFormParams.Add("apiLogin", parameterToString(localVarOptionals.ApiLogin.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ApiTransKey.IsSet() {
		localVarFormParams.Add("apiTransKey", parameterToString(localVarOptionals.ApiTransKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderId.IsSet() {
		localVarFormParams.Add("providerId", parameterToString(localVarOptionals.ProviderId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TransactionId.IsSet() {
		localVarFormParams.Add("transactionId", parameterToString(localVarOptionals.TransactionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AccountNo.IsSet() {
		localVarFormParams.Add("accountNo", parameterToString(localVarOptionals.AccountNo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DdAccountNo.IsSet() {
		localVarFormParams.Add("ddAccountNo", parameterToString(localVarOptionals.DdAccountNo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DdRoutingNo.IsSet() {
		localVarFormParams.Add("ddRoutingNo", parameterToString(localVarOptionals.DdRoutingNo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DdAccountType.IsSet() {
		localVarFormParams.Add("ddAccountType", parameterToString(localVarOptionals.DdAccountType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DdAccountDescription.IsSet() {
		localVarFormParams.Add("ddAccountDescription", parameterToString(localVarOptionals.DdAccountDescription.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v InlineResponseDefault114
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
TransactionsApiService Get Fee History
Use the Get Fee History endpoint to retrieve a list of fees for the specified customer account.   See &lt;a href&#x3D;\&quot;ref:record-set-paging\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Record-Set Pagination&lt;/a&gt; for instructions on using the paging parameters.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *TransactionsApiPostGetfeehistoryOpts - Optional Parameters:
     * @param "ApiLogin" (optional.String) - 
     * @param "ApiTransKey" (optional.String) - 
     * @param "ProviderId" (optional.Int32) - 
     * @param "TransactionId" (optional.String) - 
     * @param "AccountNo" (optional.String) - 
     * @param "StartDate" (optional.String) - 
     * @param "EndDate" (optional.String) - 
     * @param "RecordCnt" (optional.Int32) - 
     * @param "Page" (optional.Int32) - 
     * @param "ResponseContentType" (optional.String) -  Use &#x60;xml&#x60; or &#x60;json&#x60; to specify the type of response. The default value is &#x60;xml&#x60;. Use this instead of the standard &#x60;accept&#x60; header.
@return InlineResponseDefault32
*/

type TransactionsApiPostGetfeehistoryOpts struct {
    ApiLogin optional.String
    ApiTransKey optional.String
    ProviderId optional.Int32
    TransactionId optional.String
    AccountNo optional.String
    StartDate optional.String
    EndDate optional.String
    RecordCnt optional.Int32
    Page optional.Int32
    ResponseContentType optional.String
}

func (a *TransactionsApiService) PostGetfeehistory(ctx context.Context, localVarOptionals *TransactionsApiPostGetfeehistoryOpts) (InlineResponseDefault32, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponseDefault32
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/getFeeHistory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ResponseContentType.IsSet() {
		localVarHeaderParams["response-content-type"] = parameterToString(localVarOptionals.ResponseContentType.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.ApiLogin.IsSet() {
		localVarFormParams.Add("apiLogin", parameterToString(localVarOptionals.ApiLogin.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ApiTransKey.IsSet() {
		localVarFormParams.Add("apiTransKey", parameterToString(localVarOptionals.ApiTransKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderId.IsSet() {
		localVarFormParams.Add("providerId", parameterToString(localVarOptionals.ProviderId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TransactionId.IsSet() {
		localVarFormParams.Add("transactionId", parameterToString(localVarOptionals.TransactionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AccountNo.IsSet() {
		localVarFormParams.Add("accountNo", parameterToString(localVarOptionals.AccountNo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StartDate.IsSet() {
		localVarFormParams.Add("startDate", parameterToString(localVarOptionals.StartDate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EndDate.IsSet() {
		localVarFormParams.Add("endDate", parameterToString(localVarOptionals.EndDate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RecordCnt.IsSet() {
		localVarFormParams.Add("recordCnt", parameterToString(localVarOptionals.RecordCnt.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Page.IsSet() {
		localVarFormParams.Add("page", parameterToString(localVarOptionals.Page.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v InlineResponseDefault32
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
TransactionsApiService Get Fee Summary
Use Get Fee Summary to retrieve the total fee amount that was posted during the specified timespan.  See &lt;a href&#x3D;\&quot;ref:record-set-paging\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Record-Set Pagination&lt;/a&gt; for instructions on using the paging parameters.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *TransactionsApiPostGetfeesummaryOpts - Optional Parameters:
     * @param "ApiLogin" (optional.String) - 
     * @param "ApiTransKey" (optional.String) - 
     * @param "ProviderId" (optional.Int32) - 
     * @param "TransactionId" (optional.String) - 
     * @param "AccountNo" (optional.String) - 
     * @param "YtdStart" (optional.String) - 
     * @param "YtdEnd" (optional.String) - 
     * @param "MtdStart" (optional.String) - 
     * @param "MtdEnd" (optional.String) - 
     * @param "ResponseContentType" (optional.String) -  Use &#x60;xml&#x60; or &#x60;json&#x60; to specify the type of response. The default value is &#x60;xml&#x60;. Use this instead of the standard &#x60;accept&#x60; header.
@return InlineResponseDefault33
*/

type TransactionsApiPostGetfeesummaryOpts struct {
    ApiLogin optional.String
    ApiTransKey optional.String
    ProviderId optional.Int32
    TransactionId optional.String
    AccountNo optional.String
    YtdStart optional.String
    YtdEnd optional.String
    MtdStart optional.String
    MtdEnd optional.String
    ResponseContentType optional.String
}

func (a *TransactionsApiService) PostGetfeesummary(ctx context.Context, localVarOptionals *TransactionsApiPostGetfeesummaryOpts) (InlineResponseDefault33, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponseDefault33
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/getFeeSummary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ResponseContentType.IsSet() {
		localVarHeaderParams["response-content-type"] = parameterToString(localVarOptionals.ResponseContentType.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.ApiLogin.IsSet() {
		localVarFormParams.Add("apiLogin", parameterToString(localVarOptionals.ApiLogin.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ApiTransKey.IsSet() {
		localVarFormParams.Add("apiTransKey", parameterToString(localVarOptionals.ApiTransKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderId.IsSet() {
		localVarFormParams.Add("providerId", parameterToString(localVarOptionals.ProviderId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TransactionId.IsSet() {
		localVarFormParams.Add("transactionId", parameterToString(localVarOptionals.TransactionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AccountNo.IsSet() {
		localVarFormParams.Add("accountNo", parameterToString(localVarOptionals.AccountNo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.YtdStart.IsSet() {
		localVarFormParams.Add("ytdStart", parameterToString(localVarOptionals.YtdStart.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.YtdEnd.IsSet() {
		localVarFormParams.Add("ytdEnd", parameterToString(localVarOptionals.YtdEnd.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MtdStart.IsSet() {
		localVarFormParams.Add("mtdStart", parameterToString(localVarOptionals.MtdStart.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MtdEnd.IsSet() {
		localVarFormParams.Add("mtdEnd", parameterToString(localVarOptionals.MtdEnd.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v InlineResponseDefault33
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
TransactionsApiService Get Hold History
Use the Get Hold History endpoint to retrieve a history of holds that were created for the specified account by the &lt;a href&#x3D;\&quot;ref:post_createhold\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Create Hold&lt;/a&gt; endpoint. 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *TransactionsApiPostGetholdhistoryOpts - Optional Parameters:
     * @param "ApiLogin" (optional.String) - 
     * @param "ApiTransKey" (optional.String) - 
     * @param "ProviderId" (optional.Int32) - 
     * @param "TransactionId" (optional.String) - 
     * @param "AccountNo" (optional.String) - 
     * @param "ResponseContentType" (optional.String) -  Use &#x60;xml&#x60; or &#x60;json&#x60; to specify the type of response. The default value is &#x60;xml&#x60;. Use this instead of the standard &#x60;accept&#x60; header.
@return InlineResponseDefault102
*/

type TransactionsApiPostGetholdhistoryOpts struct {
    ApiLogin optional.String
    ApiTransKey optional.String
    ProviderId optional.Int32
    TransactionId optional.String
    AccountNo optional.String
    ResponseContentType optional.String
}

func (a *TransactionsApiService) PostGetholdhistory(ctx context.Context, localVarOptionals *TransactionsApiPostGetholdhistoryOpts) (InlineResponseDefault102, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponseDefault102
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/getHoldHistory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ResponseContentType.IsSet() {
		localVarHeaderParams["response-content-type"] = parameterToString(localVarOptionals.ResponseContentType.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.ApiLogin.IsSet() {
		localVarFormParams.Add("apiLogin", parameterToString(localVarOptionals.ApiLogin.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ApiTransKey.IsSet() {
		localVarFormParams.Add("apiTransKey", parameterToString(localVarOptionals.ApiTransKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderId.IsSet() {
		localVarFormParams.Add("providerId", parameterToString(localVarOptionals.ProviderId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TransactionId.IsSet() {
		localVarFormParams.Add("transactionId", parameterToString(localVarOptionals.TransactionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AccountNo.IsSet() {
		localVarFormParams.Add("accountNo", parameterToString(localVarOptionals.AccountNo.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v InlineResponseDefault102
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
TransactionsApiService Get Payment History
Use the Get Payment History endpoint to retrieve payments (credits) for a customer account during a specified period.  See &lt;a href&#x3D;\&quot;ref:record-set-paging\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Record-Set Pagination&lt;/a&gt; for instructions on using the paging parameters.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *TransactionsApiPostGetpaymenthistoryOpts - Optional Parameters:
     * @param "ApiLogin" (optional.String) - 
     * @param "ApiTransKey" (optional.String) - 
     * @param "ProviderId" (optional.Int32) - 
     * @param "TransactionId" (optional.String) - 
     * @param "AccountNo" (optional.String) - 
     * @param "StartDate" (optional.String) - 
     * @param "EndDate" (optional.String) - 
     * @param "IncludeRelated" (optional.Int32) - 
     * @param "RecordCnt" (optional.Int32) - 
     * @param "Page" (optional.Int32) - 
     * @param "ResponseContentType" (optional.String) -  Use &#x60;xml&#x60; or &#x60;json&#x60; to specify the type of response. The default value is &#x60;xml&#x60;. Use this instead of the standard &#x60;accept&#x60; header.
@return InlineResponseDefault31
*/

type TransactionsApiPostGetpaymenthistoryOpts struct {
    ApiLogin optional.String
    ApiTransKey optional.String
    ProviderId optional.Int32
    TransactionId optional.String
    AccountNo optional.String
    StartDate optional.String
    EndDate optional.String
    IncludeRelated optional.Int32
    RecordCnt optional.Int32
    Page optional.Int32
    ResponseContentType optional.String
}

func (a *TransactionsApiService) PostGetpaymenthistory(ctx context.Context, localVarOptionals *TransactionsApiPostGetpaymenthistoryOpts) (InlineResponseDefault31, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponseDefault31
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/getPaymentHistory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ResponseContentType.IsSet() {
		localVarHeaderParams["response-content-type"] = parameterToString(localVarOptionals.ResponseContentType.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.ApiLogin.IsSet() {
		localVarFormParams.Add("apiLogin", parameterToString(localVarOptionals.ApiLogin.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ApiTransKey.IsSet() {
		localVarFormParams.Add("apiTransKey", parameterToString(localVarOptionals.ApiTransKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderId.IsSet() {
		localVarFormParams.Add("providerId", parameterToString(localVarOptionals.ProviderId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TransactionId.IsSet() {
		localVarFormParams.Add("transactionId", parameterToString(localVarOptionals.TransactionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AccountNo.IsSet() {
		localVarFormParams.Add("accountNo", parameterToString(localVarOptionals.AccountNo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StartDate.IsSet() {
		localVarFormParams.Add("startDate", parameterToString(localVarOptionals.StartDate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EndDate.IsSet() {
		localVarFormParams.Add("endDate", parameterToString(localVarOptionals.EndDate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IncludeRelated.IsSet() {
		localVarFormParams.Add("includeRelated", parameterToString(localVarOptionals.IncludeRelated.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RecordCnt.IsSet() {
		localVarFormParams.Add("recordCnt", parameterToString(localVarOptionals.RecordCnt.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Page.IsSet() {
		localVarFormParams.Add("page", parameterToString(localVarOptionals.Page.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v InlineResponseDefault31
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
TransactionsApiService Get Pending Deposits
Use the Get Pending Deposits endpoint to retrieve a list of incoming ACH credits that are pending manual review for the specified account. You can approve or reject these transactions using the &lt;&lt;glossary:CST&gt;&gt; or the &lt;a href&#x3D;\&quot;ref:post_modifypendingdepositstatus\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Modify Pending Deposit Status&lt;/a&gt; endpoint. Incoming ACH credits are placed into this queue based on the operation fraud settings for your program.  See &lt;a href&#x3D;\&quot;ref:record-set-paging\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Record-Set Pagination&lt;/a&gt; for instructions on using the paging parameters.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *TransactionsApiPostGetpendingdepositsOpts - Optional Parameters:
     * @param "ApiLogin" (optional.String) - 
     * @param "ApiTransKey" (optional.String) - 
     * @param "ProviderId" (optional.Int32) - 
     * @param "TransactionId" (optional.String) - 
     * @param "AccountNo" (optional.String) - 
     * @param "StartDate" (optional.String) - 
     * @param "EndDate" (optional.String) - 
     * @param "RecordCnt" (optional.Int32) - 
     * @param "Page" (optional.Int32) - 
     * @param "ResponseContentType" (optional.String) -  Use &#x60;xml&#x60; or &#x60;json&#x60; to specify the type of response. The default value is &#x60;xml&#x60;. Use this instead of the standard &#x60;accept&#x60; header.
@return InlineResponseDefault106
*/

type TransactionsApiPostGetpendingdepositsOpts struct {
    ApiLogin optional.String
    ApiTransKey optional.String
    ProviderId optional.Int32
    TransactionId optional.String
    AccountNo optional.String
    StartDate optional.String
    EndDate optional.String
    RecordCnt optional.Int32
    Page optional.Int32
    ResponseContentType optional.String
}

func (a *TransactionsApiService) PostGetpendingdeposits(ctx context.Context, localVarOptionals *TransactionsApiPostGetpendingdepositsOpts) (InlineResponseDefault106, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponseDefault106
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/getPendingDeposits"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ResponseContentType.IsSet() {
		localVarHeaderParams["response-content-type"] = parameterToString(localVarOptionals.ResponseContentType.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.ApiLogin.IsSet() {
		localVarFormParams.Add("apiLogin", parameterToString(localVarOptionals.ApiLogin.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ApiTransKey.IsSet() {
		localVarFormParams.Add("apiTransKey", parameterToString(localVarOptionals.ApiTransKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderId.IsSet() {
		localVarFormParams.Add("providerId", parameterToString(localVarOptionals.ProviderId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TransactionId.IsSet() {
		localVarFormParams.Add("transactionId", parameterToString(localVarOptionals.TransactionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AccountNo.IsSet() {
		localVarFormParams.Add("accountNo", parameterToString(localVarOptionals.AccountNo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StartDate.IsSet() {
		localVarFormParams.Add("startDate", parameterToString(localVarOptionals.StartDate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EndDate.IsSet() {
		localVarFormParams.Add("endDate", parameterToString(localVarOptionals.EndDate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RecordCnt.IsSet() {
		localVarFormParams.Add("recordCnt", parameterToString(localVarOptionals.RecordCnt.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Page.IsSet() {
		localVarFormParams.Add("page", parameterToString(localVarOptionals.Page.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v InlineResponseDefault106
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
TransactionsApiService Get Pending Fees
Use the Get Pending Fees endpoint to retrieve the fees that have not yet been processed against the specified customer account. Most fees are processed as soon as they are created, but if the account has insufficient funds to pay the fee, the fee will be pending until there are sufficient funds.  The response data for this endpoint is also available in the &lt;a href&#x3D;\&quot;ref:post_getaccountoverview\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Get Account Overview&lt;/a&gt; response.  The response for each individual pending fee will include authorization-related transaction information, if applicable, which is in the &#x60;related_transaction&#x60; data element.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *TransactionsApiPostGetpendingfeesOpts - Optional Parameters:
     * @param "ApiLogin" (optional.String) - 
     * @param "ApiTransKey" (optional.String) - 
     * @param "ProviderId" (optional.Int32) - 
     * @param "TransactionId" (optional.String) - 
     * @param "AccountNo" (optional.String) - 
     * @param "ResponseContentType" (optional.String) -  Use &#x60;xml&#x60; or &#x60;json&#x60; to specify the type of response. The default value is &#x60;xml&#x60;. Use this instead of the standard &#x60;accept&#x60; header.
@return InlineResponseDefault28
*/

type TransactionsApiPostGetpendingfeesOpts struct {
    ApiLogin optional.String
    ApiTransKey optional.String
    ProviderId optional.Int32
    TransactionId optional.String
    AccountNo optional.String
    ResponseContentType optional.String
}

func (a *TransactionsApiService) PostGetpendingfees(ctx context.Context, localVarOptionals *TransactionsApiPostGetpendingfeesOpts) (InlineResponseDefault28, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponseDefault28
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/getPendingFees"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ResponseContentType.IsSet() {
		localVarHeaderParams["response-content-type"] = parameterToString(localVarOptionals.ResponseContentType.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.ApiLogin.IsSet() {
		localVarFormParams.Add("apiLogin", parameterToString(localVarOptionals.ApiLogin.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ApiTransKey.IsSet() {
		localVarFormParams.Add("apiTransKey", parameterToString(localVarOptionals.ApiTransKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderId.IsSet() {
		localVarFormParams.Add("providerId", parameterToString(localVarOptionals.ProviderId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TransactionId.IsSet() {
		localVarFormParams.Add("transactionId", parameterToString(localVarOptionals.TransactionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AccountNo.IsSet() {
		localVarFormParams.Add("accountNo", parameterToString(localVarOptionals.AccountNo.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v InlineResponseDefault28
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
TransactionsApiService Get Pending Merchant Credits
Use the Get Pending Merchant Credits endpoint to retrieve all merchant credits that are in the \&quot;pending\&quot; or \&quot;waiting to be processed\&quot; status. The &#x60;programId&#x60; parameter is required. Pass the &#x60;accountNo&#x60; parameter to get pending credits for the specified account.  See &lt;a href&#x3D;\&quot;ref:record-set-paging\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Record-Set Pagination&lt;/a&gt; for instructions on using the paging parameters.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *TransactionsApiPostGetpendingmerchantcreditsOpts - Optional Parameters:
     * @param "ApiLogin" (optional.String) - 
     * @param "ApiTransKey" (optional.String) - 
     * @param "ProviderId" (optional.Int32) - 
     * @param "TransactionId" (optional.String) - 
     * @param "AccountNo" (optional.String) - 
     * @param "ProgramId" (optional.Int32) - 
     * @param "RecordCnt" (optional.Int32) - 
     * @param "Page" (optional.Int32) - 
     * @param "ResponseContentType" (optional.String) -  Use &#x60;xml&#x60; or &#x60;json&#x60; to specify the type of response. The default value is &#x60;xml&#x60;. Use this instead of the standard &#x60;accept&#x60; header.
@return InlineResponseDefault104
*/

type TransactionsApiPostGetpendingmerchantcreditsOpts struct {
    ApiLogin optional.String
    ApiTransKey optional.String
    ProviderId optional.Int32
    TransactionId optional.String
    AccountNo optional.String
    ProgramId optional.Int32
    RecordCnt optional.Int32
    Page optional.Int32
    ResponseContentType optional.String
}

func (a *TransactionsApiService) PostGetpendingmerchantcredits(ctx context.Context, localVarOptionals *TransactionsApiPostGetpendingmerchantcreditsOpts) (InlineResponseDefault104, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponseDefault104
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/getPendingMerchantCredits"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ResponseContentType.IsSet() {
		localVarHeaderParams["response-content-type"] = parameterToString(localVarOptionals.ResponseContentType.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.ApiLogin.IsSet() {
		localVarFormParams.Add("apiLogin", parameterToString(localVarOptionals.ApiLogin.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ApiTransKey.IsSet() {
		localVarFormParams.Add("apiTransKey", parameterToString(localVarOptionals.ApiTransKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderId.IsSet() {
		localVarFormParams.Add("providerId", parameterToString(localVarOptionals.ProviderId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TransactionId.IsSet() {
		localVarFormParams.Add("transactionId", parameterToString(localVarOptionals.TransactionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AccountNo.IsSet() {
		localVarFormParams.Add("accountNo", parameterToString(localVarOptionals.AccountNo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProgramId.IsSet() {
		localVarFormParams.Add("programId", parameterToString(localVarOptionals.ProgramId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RecordCnt.IsSet() {
		localVarFormParams.Add("recordCnt", parameterToString(localVarOptionals.RecordCnt.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Page.IsSet() {
		localVarFormParams.Add("page", parameterToString(localVarOptionals.Page.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v InlineResponseDefault104
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
TransactionsApiService Get Scheduled Bill Payments
Use the Get Scheduled Bill Payments endpoint to retrieve the scheduled (recurrent) and future (non-recurrent) bill payments for the specified account. This endpoint returns the next-scheduled payments and all future payments that have a process date of today or later.  You can control the pagination as follows: - Scheduled payments &amp;mdash; &#x60;recordCntScheduled&#x60; and &#x60;pageScheduled&#x60; - Future payments &amp;mdash; &#x60;recordCntFuture&#x60; and &#x60;pageFuture&#x60; - Both scheduled and future payments &amp;mdash; &#x60;recordCnt&#x60; and &#x60;page&#x60;.  See &lt;a href&#x3D;\&quot;ref:record-set-paging\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Record-Set Pagination&lt;/a&gt; for instructions on using the paging parameters.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *TransactionsApiPostGetscheduledbillpaymentsOpts - Optional Parameters:
     * @param "ApiLogin" (optional.String) - 
     * @param "ApiTransKey" (optional.String) - 
     * @param "ProviderId" (optional.Int32) - 
     * @param "TransactionId" (optional.String) - 
     * @param "AccountNo" (optional.String) - 
     * @param "RecordCnt" (optional.Int32) - 
     * @param "Page" (optional.Int32) - 
     * @param "RecordCntScheduled" (optional.Int32) - 
     * @param "PageScheduled" (optional.Int32) - 
     * @param "RecordCntFuture" (optional.Int32) - 
     * @param "PageFuture" (optional.Int32) - 
     * @param "ResponseContentType" (optional.String) -  Use &#x60;xml&#x60; or &#x60;json&#x60; to specify the type of response. The default value is &#x60;xml&#x60;. Use this instead of the standard &#x60;accept&#x60; header.
@return InlineResponseDefault108
*/

type TransactionsApiPostGetscheduledbillpaymentsOpts struct {
    ApiLogin optional.String
    ApiTransKey optional.String
    ProviderId optional.Int32
    TransactionId optional.String
    AccountNo optional.String
    RecordCnt optional.Int32
    Page optional.Int32
    RecordCntScheduled optional.Int32
    PageScheduled optional.Int32
    RecordCntFuture optional.Int32
    PageFuture optional.Int32
    ResponseContentType optional.String
}

func (a *TransactionsApiService) PostGetscheduledbillpayments(ctx context.Context, localVarOptionals *TransactionsApiPostGetscheduledbillpaymentsOpts) (InlineResponseDefault108, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponseDefault108
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/getScheduledBillPayments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ResponseContentType.IsSet() {
		localVarHeaderParams["response-content-type"] = parameterToString(localVarOptionals.ResponseContentType.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.ApiLogin.IsSet() {
		localVarFormParams.Add("apiLogin", parameterToString(localVarOptionals.ApiLogin.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ApiTransKey.IsSet() {
		localVarFormParams.Add("apiTransKey", parameterToString(localVarOptionals.ApiTransKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderId.IsSet() {
		localVarFormParams.Add("providerId", parameterToString(localVarOptionals.ProviderId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TransactionId.IsSet() {
		localVarFormParams.Add("transactionId", parameterToString(localVarOptionals.TransactionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AccountNo.IsSet() {
		localVarFormParams.Add("accountNo", parameterToString(localVarOptionals.AccountNo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RecordCnt.IsSet() {
		localVarFormParams.Add("recordCnt", parameterToString(localVarOptionals.RecordCnt.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Page.IsSet() {
		localVarFormParams.Add("page", parameterToString(localVarOptionals.Page.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RecordCntScheduled.IsSet() {
		localVarFormParams.Add("recordCntScheduled", parameterToString(localVarOptionals.RecordCntScheduled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PageScheduled.IsSet() {
		localVarFormParams.Add("pageScheduled", parameterToString(localVarOptionals.PageScheduled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RecordCntFuture.IsSet() {
		localVarFormParams.Add("recordCntFuture", parameterToString(localVarOptionals.RecordCntFuture.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PageFuture.IsSet() {
		localVarFormParams.Add("pageFuture", parameterToString(localVarOptionals.PageFuture.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v InlineResponseDefault108
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
TransactionsApiService Get Transaction History
Use the Get Transaction History endpoint to retrieve a list of transactions during a specified timespan. This endpoint does not return unsettled authorizations.  As desired, use the &#x60;act_type&#x60; field in the response to filter the responses by transaction type.  See &lt;a href&#x3D;\&quot;ref:record-set-paging\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Record-Set Pagination&lt;/a&gt; for instructions on using the paging parameters.  Open the Recipe below to see a response example.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *TransactionsApiPostGettranshistoryOpts - Optional Parameters:
     * @param "ApiLogin" (optional.String) - 
     * @param "ApiTransKey" (optional.String) - 
     * @param "ProviderId" (optional.Int32) - 
     * @param "TransactionId" (optional.String) - 
     * @param "AccountNo" (optional.String) - 
     * @param "StartDate" (optional.String) - 
     * @param "EndDate" (optional.String) - 
     * @param "RecordCnt" (optional.Int32) - 
     * @param "Page" (optional.Int32) - 
     * @param "IncludeRelated" (optional.Int32) - 
     * @param "ResponseContentType" (optional.String) -  Use &#x60;xml&#x60; or &#x60;json&#x60; to specify the type of response. The default value is &#x60;xml&#x60;. Use this instead of the standard &#x60;accept&#x60; header.
@return InlineResponseDefault
*/

type TransactionsApiPostGettranshistoryOpts struct {
    ApiLogin optional.String
    ApiTransKey optional.String
    ProviderId optional.Int32
    TransactionId optional.String
    AccountNo optional.String
    StartDate optional.String
    EndDate optional.String
    RecordCnt optional.Int32
    Page optional.Int32
    IncludeRelated optional.Int32
    ResponseContentType optional.String
}

func (a *TransactionsApiService) PostGettranshistory(ctx context.Context, localVarOptionals *TransactionsApiPostGettranshistoryOpts) (InlineResponseDefault, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponseDefault
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/getTransHistory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ResponseContentType.IsSet() {
		localVarHeaderParams["response-content-type"] = parameterToString(localVarOptionals.ResponseContentType.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.ApiLogin.IsSet() {
		localVarFormParams.Add("apiLogin", parameterToString(localVarOptionals.ApiLogin.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ApiTransKey.IsSet() {
		localVarFormParams.Add("apiTransKey", parameterToString(localVarOptionals.ApiTransKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderId.IsSet() {
		localVarFormParams.Add("providerId", parameterToString(localVarOptionals.ProviderId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TransactionId.IsSet() {
		localVarFormParams.Add("transactionId", parameterToString(localVarOptionals.TransactionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AccountNo.IsSet() {
		localVarFormParams.Add("accountNo", parameterToString(localVarOptionals.AccountNo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StartDate.IsSet() {
		localVarFormParams.Add("startDate", parameterToString(localVarOptionals.StartDate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EndDate.IsSet() {
		localVarFormParams.Add("endDate", parameterToString(localVarOptionals.EndDate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RecordCnt.IsSet() {
		localVarFormParams.Add("recordCnt", parameterToString(localVarOptionals.RecordCnt.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Page.IsSet() {
		localVarFormParams.Add("page", parameterToString(localVarOptionals.Page.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IncludeRelated.IsSet() {
		localVarFormParams.Add("includeRelated", parameterToString(localVarOptionals.IncludeRelated.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v InlineResponseDefault
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
TransactionsApiService Modify ACH Account
Use the Modify ACH Account endpoint to change an existing ACH account&#x27;s information. You can add the same ACH account to multiple customer accounts, but you cannot add the same ACH account to the same customer account multiple times.  For instructions on using this endpoint see &lt;a href&#x3D;\&quot;doc:ach-endpoints#modifying-ach-accounts\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Modifying ACH Accounts&lt;/a&gt; in the *ACH Endpoints* guide.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *TransactionsApiPostModifyachaccountOpts - Optional Parameters:
     * @param "ApiLogin" (optional.String) - 
     * @param "ApiTransKey" (optional.String) - 
     * @param "ProviderId" (optional.Int32) - 
     * @param "TransactionId" (optional.String) - 
     * @param "AccountNo" (optional.String) - 
     * @param "AchAccountId" (optional.Int32) - 
     * @param "Name" (optional.String) - 
     * @param "Type_" (optional.String) - 
     * @param "AchAccountNo" (optional.String) - 
     * @param "AchRoutingNo" (optional.String) - 
     * @param "EntityType" (optional.String) - 
     * @param "FirstName" (optional.String) - 
     * @param "LastName" (optional.String) - 
     * @param "FileFirstName" (optional.String) - 
     * @param "FileLastName" (optional.String) - 
     * @param "CompanyName" (optional.String) - 
     * @param "FileCompanyName" (optional.String) - 
     * @param "Location" (optional.String) - 
     * @param "LocationType" (optional.Int32) - 
     * @param "ResponseContentType" (optional.String) -  Use &#x60;xml&#x60; or &#x60;json&#x60; to specify the type of response. The default value is &#x60;xml&#x60;. Use this instead of the standard &#x60;accept&#x60; header.
@return InlineResponseDefault89
*/

type TransactionsApiPostModifyachaccountOpts struct {
    ApiLogin optional.String
    ApiTransKey optional.String
    ProviderId optional.Int32
    TransactionId optional.String
    AccountNo optional.String
    AchAccountId optional.Int32
    Name optional.String
    Type_ optional.String
    AchAccountNo optional.String
    AchRoutingNo optional.String
    EntityType optional.String
    FirstName optional.String
    LastName optional.String
    FileFirstName optional.String
    FileLastName optional.String
    CompanyName optional.String
    FileCompanyName optional.String
    Location optional.String
    LocationType optional.Int32
    ResponseContentType optional.String
}

func (a *TransactionsApiService) PostModifyachaccount(ctx context.Context, localVarOptionals *TransactionsApiPostModifyachaccountOpts) (InlineResponseDefault89, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponseDefault89
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/modifyAchAccount"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ResponseContentType.IsSet() {
		localVarHeaderParams["response-content-type"] = parameterToString(localVarOptionals.ResponseContentType.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.ApiLogin.IsSet() {
		localVarFormParams.Add("apiLogin", parameterToString(localVarOptionals.ApiLogin.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ApiTransKey.IsSet() {
		localVarFormParams.Add("apiTransKey", parameterToString(localVarOptionals.ApiTransKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderId.IsSet() {
		localVarFormParams.Add("providerId", parameterToString(localVarOptionals.ProviderId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TransactionId.IsSet() {
		localVarFormParams.Add("transactionId", parameterToString(localVarOptionals.TransactionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AccountNo.IsSet() {
		localVarFormParams.Add("accountNo", parameterToString(localVarOptionals.AccountNo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AchAccountId.IsSet() {
		localVarFormParams.Add("achAccountId", parameterToString(localVarOptionals.AchAccountId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarFormParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarFormParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AchAccountNo.IsSet() {
		localVarFormParams.Add("achAccountNo", parameterToString(localVarOptionals.AchAccountNo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AchRoutingNo.IsSet() {
		localVarFormParams.Add("achRoutingNo", parameterToString(localVarOptionals.AchRoutingNo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EntityType.IsSet() {
		localVarFormParams.Add("entityType", parameterToString(localVarOptionals.EntityType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FirstName.IsSet() {
		localVarFormParams.Add("firstName", parameterToString(localVarOptionals.FirstName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LastName.IsSet() {
		localVarFormParams.Add("lastName", parameterToString(localVarOptionals.LastName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FileFirstName.IsSet() {
		localVarFormParams.Add("fileFirstName", parameterToString(localVarOptionals.FileFirstName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FileLastName.IsSet() {
		localVarFormParams.Add("fileLastName", parameterToString(localVarOptionals.FileLastName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CompanyName.IsSet() {
		localVarFormParams.Add("companyName", parameterToString(localVarOptionals.CompanyName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FileCompanyName.IsSet() {
		localVarFormParams.Add("fileCompanyName", parameterToString(localVarOptionals.FileCompanyName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Location.IsSet() {
		localVarFormParams.Add("location", parameterToString(localVarOptionals.Location.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LocationType.IsSet() {
		localVarFormParams.Add("locationType", parameterToString(localVarOptionals.LocationType.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v InlineResponseDefault89
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
TransactionsApiService Modify Paper Biller
Use the Modify Paper Biller endpoint to update a paper biller. All non-required fields are nullifiable. To cancel a scheduled series, either set &#x60;endDate&#x60; to the current date or pass &#x60;Null&#x60; for &#x60;frequencyType&#x60;, &#x60;nextDate&#x60; and &#x60;endDate&#x60;.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *TransactionsApiPostModifypaperbillerOpts - Optional Parameters:
     * @param "ApiLogin" (optional.String) - 
     * @param "ApiTransKey" (optional.String) - 
     * @param "ProviderId" (optional.Int32) - 
     * @param "TransactionId" (optional.String) - 
     * @param "AccountNo" (optional.String) - 
     * @param "BillerId" (optional.Int32) - 
     * @param "FrequencyType" (optional.String) - 
     * @param "NextDate" (optional.Time) - 
     * @param "EndDate" (optional.Time) - 
     * @param "Amount" (optional.Float32) - 
     * @param "BillerAddress1" (optional.String) - 
     * @param "BillerAddress2" (optional.String) - 
     * @param "BillerCity" (optional.String) - 
     * @param "BillerState" (optional.String) - 
     * @param "BillerZip" (optional.String) - 
     * @param "BillerPhone" (optional.String) - 
     * @param "ResponseContentType" (optional.String) -  Use &#x60;xml&#x60; or &#x60;json&#x60; to specify the type of response. The default value is &#x60;xml&#x60;. Use this instead of the standard &#x60;accept&#x60; header.
@return InlineResponseDefault11
*/

type TransactionsApiPostModifypaperbillerOpts struct {
    ApiLogin optional.String
    ApiTransKey optional.String
    ProviderId optional.Int32
    TransactionId optional.String
    AccountNo optional.String
    BillerId optional.Int32
    FrequencyType optional.String
    NextDate optional.Time
    EndDate optional.Time
    Amount optional.Float32
    BillerAddress1 optional.String
    BillerAddress2 optional.String
    BillerCity optional.String
    BillerState optional.String
    BillerZip optional.String
    BillerPhone optional.String
    ResponseContentType optional.String
}

func (a *TransactionsApiService) PostModifypaperbiller(ctx context.Context, localVarOptionals *TransactionsApiPostModifypaperbillerOpts) (InlineResponseDefault11, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponseDefault11
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/modifyPaperBiller"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ResponseContentType.IsSet() {
		localVarHeaderParams["response-content-type"] = parameterToString(localVarOptionals.ResponseContentType.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.ApiLogin.IsSet() {
		localVarFormParams.Add("apiLogin", parameterToString(localVarOptionals.ApiLogin.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ApiTransKey.IsSet() {
		localVarFormParams.Add("apiTransKey", parameterToString(localVarOptionals.ApiTransKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderId.IsSet() {
		localVarFormParams.Add("providerId", parameterToString(localVarOptionals.ProviderId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TransactionId.IsSet() {
		localVarFormParams.Add("transactionId", parameterToString(localVarOptionals.TransactionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AccountNo.IsSet() {
		localVarFormParams.Add("accountNo", parameterToString(localVarOptionals.AccountNo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BillerId.IsSet() {
		localVarFormParams.Add("billerId", parameterToString(localVarOptionals.BillerId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FrequencyType.IsSet() {
		localVarFormParams.Add("frequencyType", parameterToString(localVarOptionals.FrequencyType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NextDate.IsSet() {
		localVarFormParams.Add("nextDate", parameterToString(localVarOptionals.NextDate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EndDate.IsSet() {
		localVarFormParams.Add("endDate", parameterToString(localVarOptionals.EndDate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Amount.IsSet() {
		localVarFormParams.Add("amount", parameterToString(localVarOptionals.Amount.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BillerAddress1.IsSet() {
		localVarFormParams.Add("billerAddress1", parameterToString(localVarOptionals.BillerAddress1.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BillerAddress2.IsSet() {
		localVarFormParams.Add("billerAddress2", parameterToString(localVarOptionals.BillerAddress2.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BillerCity.IsSet() {
		localVarFormParams.Add("billerCity", parameterToString(localVarOptionals.BillerCity.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BillerState.IsSet() {
		localVarFormParams.Add("billerState", parameterToString(localVarOptionals.BillerState.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BillerZip.IsSet() {
		localVarFormParams.Add("billerZip", parameterToString(localVarOptionals.BillerZip.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BillerPhone.IsSet() {
		localVarFormParams.Add("billerPhone", parameterToString(localVarOptionals.BillerPhone.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v InlineResponseDefault11
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
TransactionsApiService Modify Pending Deposit Status
Use the Modify Pending Deposit Status endpoint to either post or return pending direct ACH deposits that are returned by &lt;a href&#x3D;\&quot;ref:post_getpendingdeposits\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Get Pending Deposits&lt;/a&gt;. This endpoint is intended for a custom fraud monitoring and resolution strategy. Consult with Galileo to configure your program appropriately.  For more information on this endpoint see &lt;a href&#x3D;\&quot;doc:ach-endpoints#modifying-a-pending-ach-deposit-status\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Modifying a pending ACH deposit status&lt;/a&gt; in the *ACH Endpoints* guide.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *TransactionsApiPostModifypendingdepositstatusOpts - Optional Parameters:
     * @param "ApiLogin" (optional.String) - 
     * @param "ApiTransKey" (optional.String) - 
     * @param "ProviderId" (optional.Int32) - 
     * @param "TransactionId" (optional.String) - 
     * @param "AccountNo" (optional.String) - 
     * @param "ExternalAccountId" (optional.String) - 
     * @param "DepositTransactionId" (optional.Int32) - 
     * @param "ActionType" (optional.String) - 
     * @param "CategoryCode" (optional.String) - 
     * @param "CategoryType" (optional.String) - 
     * @param "RetCode" (optional.String) - 
     * @param "ResponseContentType" (optional.String) -  Use &#x60;xml&#x60; or &#x60;json&#x60; to specify the type of response. The default value is &#x60;xml&#x60;. Use this instead of the standard &#x60;accept&#x60; header.
@return InlineResponseDefault105
*/

type TransactionsApiPostModifypendingdepositstatusOpts struct {
    ApiLogin optional.String
    ApiTransKey optional.String
    ProviderId optional.Int32
    TransactionId optional.String
    AccountNo optional.String
    ExternalAccountId optional.String
    DepositTransactionId optional.Int32
    ActionType optional.String
    CategoryCode optional.String
    CategoryType optional.String
    RetCode optional.String
    ResponseContentType optional.String
}

func (a *TransactionsApiService) PostModifypendingdepositstatus(ctx context.Context, localVarOptionals *TransactionsApiPostModifypendingdepositstatusOpts) (InlineResponseDefault105, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponseDefault105
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/modifyPendingDepositStatus"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ResponseContentType.IsSet() {
		localVarHeaderParams["response-content-type"] = parameterToString(localVarOptionals.ResponseContentType.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.ApiLogin.IsSet() {
		localVarFormParams.Add("apiLogin", parameterToString(localVarOptionals.ApiLogin.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ApiTransKey.IsSet() {
		localVarFormParams.Add("apiTransKey", parameterToString(localVarOptionals.ApiTransKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderId.IsSet() {
		localVarFormParams.Add("providerId", parameterToString(localVarOptionals.ProviderId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TransactionId.IsSet() {
		localVarFormParams.Add("transactionId", parameterToString(localVarOptionals.TransactionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AccountNo.IsSet() {
		localVarFormParams.Add("accountNo", parameterToString(localVarOptionals.AccountNo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ExternalAccountId.IsSet() {
		localVarFormParams.Add("externalAccountId", parameterToString(localVarOptionals.ExternalAccountId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DepositTransactionId.IsSet() {
		localVarFormParams.Add("depositTransactionId", parameterToString(localVarOptionals.DepositTransactionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ActionType.IsSet() {
		localVarFormParams.Add("actionType", parameterToString(localVarOptionals.ActionType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CategoryCode.IsSet() {
		localVarFormParams.Add("categoryCode", parameterToString(localVarOptionals.CategoryCode.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CategoryType.IsSet() {
		localVarFormParams.Add("categoryType", parameterToString(localVarOptionals.CategoryType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RetCode.IsSet() {
		localVarFormParams.Add("retCode", parameterToString(localVarOptionals.RetCode.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v InlineResponseDefault105
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
TransactionsApiService Modify RPPS Biller
Use the Modify RPPS Biller endpoint to update an &lt;&lt;glossary:RPPS&gt;&gt; biller. All non-required fields are nullifiable. To cancel a scheduled series, either set &#x60;endDate&#x60; to the current date or pass &#x60;Null&#x60; for &#x60;frequencyType&#x60;, &#x60;nextDate&#x60; and &#x60;endDate&#x60;.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *TransactionsApiPostModifyrppsbillerOpts - Optional Parameters:
     * @param "ApiLogin" (optional.String) - 
     * @param "ApiTransKey" (optional.String) - 
     * @param "ProviderId" (optional.Int32) - 
     * @param "TransactionId" (optional.String) - 
     * @param "AccountNo" (optional.String) - 
     * @param "BillerId" (optional.Int32) - 
     * @param "FrequencyType" (optional.String) - 
     * @param "NextDate" (optional.Time) - 
     * @param "EndDate" (optional.Time) - 
     * @param "Amount" (optional.Float32) - 
     * @param "ResponseContentType" (optional.String) -  Use &#x60;xml&#x60; or &#x60;json&#x60; to specify the type of response. The default value is &#x60;xml&#x60;. Use this instead of the standard &#x60;accept&#x60; header.
@return InlineResponseDefault16
*/

type TransactionsApiPostModifyrppsbillerOpts struct {
    ApiLogin optional.String
    ApiTransKey optional.String
    ProviderId optional.Int32
    TransactionId optional.String
    AccountNo optional.String
    BillerId optional.Int32
    FrequencyType optional.String
    NextDate optional.Time
    EndDate optional.Time
    Amount optional.Float32
    ResponseContentType optional.String
}

func (a *TransactionsApiService) PostModifyrppsbiller(ctx context.Context, localVarOptionals *TransactionsApiPostModifyrppsbillerOpts) (InlineResponseDefault16, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponseDefault16
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/modifyRppsBiller"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ResponseContentType.IsSet() {
		localVarHeaderParams["response-content-type"] = parameterToString(localVarOptionals.ResponseContentType.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.ApiLogin.IsSet() {
		localVarFormParams.Add("apiLogin", parameterToString(localVarOptionals.ApiLogin.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ApiTransKey.IsSet() {
		localVarFormParams.Add("apiTransKey", parameterToString(localVarOptionals.ApiTransKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderId.IsSet() {
		localVarFormParams.Add("providerId", parameterToString(localVarOptionals.ProviderId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TransactionId.IsSet() {
		localVarFormParams.Add("transactionId", parameterToString(localVarOptionals.TransactionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AccountNo.IsSet() {
		localVarFormParams.Add("accountNo", parameterToString(localVarOptionals.AccountNo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BillerId.IsSet() {
		localVarFormParams.Add("billerId", parameterToString(localVarOptionals.BillerId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FrequencyType.IsSet() {
		localVarFormParams.Add("frequencyType", parameterToString(localVarOptionals.FrequencyType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NextDate.IsSet() {
		localVarFormParams.Add("nextDate", parameterToString(localVarOptionals.NextDate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EndDate.IsSet() {
		localVarFormParams.Add("endDate", parameterToString(localVarOptionals.EndDate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Amount.IsSet() {
		localVarFormParams.Add("amount", parameterToString(localVarOptionals.Amount.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v InlineResponseDefault16
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
TransactionsApiService Remove ACH Account
Use the Remove ACH Account endpoint to delete an ACH account from the specified customer account.  For more information on this endpoint see &lt;a href&#x3D;\&quot;doc:ach-endpoints#removing-an-ach-account\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Removing an ACH account&lt;/a&gt; in the *ACH Endpoints* guide.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *TransactionsApiPostRemoveachaccountOpts - Optional Parameters:
     * @param "ApiLogin" (optional.String) - 
     * @param "ApiTransKey" (optional.String) - 
     * @param "ProviderId" (optional.Int32) - 
     * @param "TransactionId" (optional.String) - 
     * @param "AccountNo" (optional.String) - 
     * @param "AchAccountId" (optional.Int32) - 
     * @param "ResponseContentType" (optional.String) -  Use &#x60;xml&#x60; or &#x60;json&#x60; to specify the type of response. The default value is &#x60;xml&#x60;. Use this instead of the standard &#x60;accept&#x60; header.
@return InlineResponseDefault91
*/

type TransactionsApiPostRemoveachaccountOpts struct {
    ApiLogin optional.String
    ApiTransKey optional.String
    ProviderId optional.Int32
    TransactionId optional.String
    AccountNo optional.String
    AchAccountId optional.Int32
    ResponseContentType optional.String
}

func (a *TransactionsApiService) PostRemoveachaccount(ctx context.Context, localVarOptionals *TransactionsApiPostRemoveachaccountOpts) (InlineResponseDefault91, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponseDefault91
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/removeAchAccount"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ResponseContentType.IsSet() {
		localVarHeaderParams["response-content-type"] = parameterToString(localVarOptionals.ResponseContentType.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.ApiLogin.IsSet() {
		localVarFormParams.Add("apiLogin", parameterToString(localVarOptionals.ApiLogin.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ApiTransKey.IsSet() {
		localVarFormParams.Add("apiTransKey", parameterToString(localVarOptionals.ApiTransKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderId.IsSet() {
		localVarFormParams.Add("providerId", parameterToString(localVarOptionals.ProviderId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TransactionId.IsSet() {
		localVarFormParams.Add("transactionId", parameterToString(localVarOptionals.TransactionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AccountNo.IsSet() {
		localVarFormParams.Add("accountNo", parameterToString(localVarOptionals.AccountNo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AchAccountId.IsSet() {
		localVarFormParams.Add("achAccountId", parameterToString(localVarOptionals.AchAccountId.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v InlineResponseDefault91
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
TransactionsApiService Remove Biller
Use the Remove Biller endpoint to delete an &lt;&lt;glossary:RPPS&gt;&gt; or paper biller. When you delete a biller, the future scheduled transactions for that biller are not deleted.  See &lt;a href&#x3D;\&quot;doc:managing-billpay-transactions\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Managing Billpay Transactions&lt;/a&gt; for instructions on using this endpoint.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *TransactionsApiPostRemovebillerOpts - Optional Parameters:
     * @param "ApiLogin" (optional.String) - 
     * @param "ApiTransKey" (optional.String) - 
     * @param "ProviderId" (optional.Int32) - 
     * @param "TransactionId" (optional.String) - 
     * @param "AccountNo" (optional.String) - 
     * @param "BillerId" (optional.Int32) - 
     * @param "ResponseContentType" (optional.String) -  Use &#x60;xml&#x60; or &#x60;json&#x60; to specify the type of response. The default value is &#x60;xml&#x60;. Use this instead of the standard &#x60;accept&#x60; header.
@return InlineResponseDefault16
*/

type TransactionsApiPostRemovebillerOpts struct {
    ApiLogin optional.String
    ApiTransKey optional.String
    ProviderId optional.Int32
    TransactionId optional.String
    AccountNo optional.String
    BillerId optional.Int32
    ResponseContentType optional.String
}

func (a *TransactionsApiService) PostRemovebiller(ctx context.Context, localVarOptionals *TransactionsApiPostRemovebillerOpts) (InlineResponseDefault16, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponseDefault16
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/removeBiller"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ResponseContentType.IsSet() {
		localVarHeaderParams["response-content-type"] = parameterToString(localVarOptionals.ResponseContentType.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.ApiLogin.IsSet() {
		localVarFormParams.Add("apiLogin", parameterToString(localVarOptionals.ApiLogin.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ApiTransKey.IsSet() {
		localVarFormParams.Add("apiTransKey", parameterToString(localVarOptionals.ApiTransKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderId.IsSet() {
		localVarFormParams.Add("providerId", parameterToString(localVarOptionals.ProviderId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TransactionId.IsSet() {
		localVarFormParams.Add("transactionId", parameterToString(localVarOptionals.TransactionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AccountNo.IsSet() {
		localVarFormParams.Add("accountNo", parameterToString(localVarOptionals.AccountNo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BillerId.IsSet() {
		localVarFormParams.Add("billerId", parameterToString(localVarOptionals.BillerId.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v InlineResponseDefault16
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
TransactionsApiService Reverse Account Transfer
Use the Reverse Account Transfer endpoint to reverse out a transaction made with the &lt;a href&#x3D;\&quot;ref:post_createaccounttransfer\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Create Account Transfer&lt;/a&gt; endpoint. Only a successful Create Account Transfer transaction (response &#x60;status: 0&#x60;) can be reversed using Reverse Account Transfer. Pass the &#x60;transactionId&#x60; of the endpoint request to be reversed instead of passing a new value. Pass the original sending account in &#x60;accountNo&#x60;.  Consult the &lt;a href&#x3D;\&quot;doc:creating-an-internal-transfer\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Creating an Internal Transfer&lt;/a&gt; guide for instructions on using this endpoint.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *TransactionsApiPostReverseaccounttransferOpts - Optional Parameters:
     * @param "ApiLogin" (optional.String) - 
     * @param "ApiTransKey" (optional.String) - 
     * @param "ProviderId" (optional.Int32) - 
     * @param "TransactionId" (optional.String) - 
     * @param "AccountNo" (optional.String) - 
     * @param "ResponseContentType" (optional.String) -  Use &#x60;xml&#x60; or &#x60;json&#x60; to specify the type of response. The default value is &#x60;xml&#x60;. Use this instead of the standard &#x60;accept&#x60; header.
@return InlineResponseDefault103
*/

type TransactionsApiPostReverseaccounttransferOpts struct {
    ApiLogin optional.String
    ApiTransKey optional.String
    ProviderId optional.Int32
    TransactionId optional.String
    AccountNo optional.String
    ResponseContentType optional.String
}

func (a *TransactionsApiService) PostReverseaccounttransfer(ctx context.Context, localVarOptionals *TransactionsApiPostReverseaccounttransferOpts) (InlineResponseDefault103, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponseDefault103
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/reverseAccountTransfer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ResponseContentType.IsSet() {
		localVarHeaderParams["response-content-type"] = parameterToString(localVarOptionals.ResponseContentType.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.ApiLogin.IsSet() {
		localVarFormParams.Add("apiLogin", parameterToString(localVarOptionals.ApiLogin.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ApiTransKey.IsSet() {
		localVarFormParams.Add("apiTransKey", parameterToString(localVarOptionals.ApiTransKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderId.IsSet() {
		localVarFormParams.Add("providerId", parameterToString(localVarOptionals.ProviderId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TransactionId.IsSet() {
		localVarFormParams.Add("transactionId", parameterToString(localVarOptionals.TransactionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AccountNo.IsSet() {
		localVarFormParams.Add("accountNo", parameterToString(localVarOptionals.AccountNo.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v InlineResponseDefault103
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
TransactionsApiService Reverse Adjustment
Use the Reverse Adjustment endpoint to reverse out a transaction that was created with the &lt;a href&#x3D;\&quot;ref:post_createadjustment\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Create Adjustment&lt;/a&gt; endpoint. Pass the &#x60;transactionId&#x60; of the endpoint request to be reversed instead of passing a new value.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *TransactionsApiPostReverseadjustmentOpts - Optional Parameters:
     * @param "ApiLogin" (optional.String) - 
     * @param "ApiTransKey" (optional.String) - 
     * @param "ProviderId" (optional.Int32) - 
     * @param "TransactionId" (optional.Int64) - 
     * @param "AccountNo" (optional.String) - 
     * @param "VerifyOnly" (optional.Int32) - 
     * @param "ResponseContentType" (optional.String) -  Use &#x60;xml&#x60; or &#x60;json&#x60; to specify the type of response. The default value is &#x60;xml&#x60;. Use this instead of the standard &#x60;accept&#x60; header.
@return InlineResponseDefault100
*/

type TransactionsApiPostReverseadjustmentOpts struct {
    ApiLogin optional.String
    ApiTransKey optional.String
    ProviderId optional.Int32
    TransactionId optional.Int64
    AccountNo optional.String
    VerifyOnly optional.Int32
    ResponseContentType optional.String
}

func (a *TransactionsApiService) PostReverseadjustment(ctx context.Context, localVarOptionals *TransactionsApiPostReverseadjustmentOpts) (InlineResponseDefault100, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponseDefault100
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/reverseAdjustment"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ResponseContentType.IsSet() {
		localVarHeaderParams["response-content-type"] = parameterToString(localVarOptionals.ResponseContentType.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.ApiLogin.IsSet() {
		localVarFormParams.Add("apiLogin", parameterToString(localVarOptionals.ApiLogin.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ApiTransKey.IsSet() {
		localVarFormParams.Add("apiTransKey", parameterToString(localVarOptionals.ApiTransKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderId.IsSet() {
		localVarFormParams.Add("providerId", parameterToString(localVarOptionals.ProviderId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TransactionId.IsSet() {
		localVarFormParams.Add("transactionId", parameterToString(localVarOptionals.TransactionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AccountNo.IsSet() {
		localVarFormParams.Add("accountNo", parameterToString(localVarOptionals.AccountNo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VerifyOnly.IsSet() {
		localVarFormParams.Add("verifyOnly", parameterToString(localVarOptionals.VerifyOnly.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v InlineResponseDefault100
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
TransactionsApiService Reverse Fee
Use the Reverse Fee endpoint to reverse out a fee that was created with the &lt;a href&#x3D;\&quot;ref:post_assessfee\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Assess Fee&lt;/a&gt; endpoint or created elsewhere in the Galileo system.  If the fee was created with Assess Fee, pass the &#x60;transactionId&#x60; of the endpoint request to be reversed instead of passing a new value. If the fee was not created by Assess Fee, pass &#x60;feeId&#x60;, which you can retrieve with the &lt;a href&#x3D;\&quot;ref:post_getfeehistory\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Get Fee History&lt;/a&gt; endpoint.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *TransactionsApiPostReversefeeOpts - Optional Parameters:
     * @param "ApiLogin" (optional.String) - 
     * @param "ApiTransKey" (optional.String) - 
     * @param "ProviderId" (optional.Int32) - 
     * @param "TransactionId" (optional.String) - 
     * @param "AccountNo" (optional.String) - 
     * @param "FeeId" (optional.Int32) - 
     * @param "VerifyOnly" (optional.String) - 
     * @param "ResponseContentType" (optional.String) -  Use &#x60;xml&#x60; or &#x60;json&#x60; to specify the type of response. The default value is &#x60;xml&#x60;. Use this instead of the standard &#x60;accept&#x60; header.
@return InlineResponseDefault98
*/

type TransactionsApiPostReversefeeOpts struct {
    ApiLogin optional.String
    ApiTransKey optional.String
    ProviderId optional.Int32
    TransactionId optional.String
    AccountNo optional.String
    FeeId optional.Int32
    VerifyOnly optional.String
    ResponseContentType optional.String
}

func (a *TransactionsApiService) PostReversefee(ctx context.Context, localVarOptionals *TransactionsApiPostReversefeeOpts) (InlineResponseDefault98, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponseDefault98
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/reverseFee"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ResponseContentType.IsSet() {
		localVarHeaderParams["response-content-type"] = parameterToString(localVarOptionals.ResponseContentType.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.ApiLogin.IsSet() {
		localVarFormParams.Add("apiLogin", parameterToString(localVarOptionals.ApiLogin.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ApiTransKey.IsSet() {
		localVarFormParams.Add("apiTransKey", parameterToString(localVarOptionals.ApiTransKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderId.IsSet() {
		localVarFormParams.Add("providerId", parameterToString(localVarOptionals.ProviderId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TransactionId.IsSet() {
		localVarFormParams.Add("transactionId", parameterToString(localVarOptionals.TransactionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AccountNo.IsSet() {
		localVarFormParams.Add("accountNo", parameterToString(localVarOptionals.AccountNo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FeeId.IsSet() {
		localVarFormParams.Add("feeId", parameterToString(localVarOptionals.FeeId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VerifyOnly.IsSet() {
		localVarFormParams.Add("verifyOnly", parameterToString(localVarOptionals.VerifyOnly.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v InlineResponseDefault98
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
TransactionsApiService Reverse Payment
Use the Reverse Payment endpoint to reverse out a payment transaction that was created with the &lt;a href&#x3D;\&quot;ref:post_createpayment\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Create Payment&lt;/a&gt; endpoint. Pass the &#x60;transactionId&#x60; of the endpoint request to be reversed instead of passing a new value.  [block:callout]  { \&quot;type\&quot;: \&quot;info\&quot;, \&quot;title\&quot;: \&quot;Note\&quot;, \&quot;body\&quot;: \&quot;The account balance must be sufficient to cover the amount of the reversal. If it is not, a reverse payment fee may be assessed, according to product settings.\&quot; } [/block]  Consult the &lt;a href&#x3D;\&quot;doc:creating-a-payment\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Creating a Payment&lt;/a&gt; guide for instructions on using this endpoint.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *TransactionsApiPostReversepaymentOpts - Optional Parameters:
     * @param "ApiLogin" (optional.String) - 
     * @param "ApiTransKey" (optional.String) - 
     * @param "ProviderId" (optional.Int32) - 
     * @param "TransactionId" (optional.String) - 
     * @param "AccountNo" (optional.String) - 
     * @param "VerifyOnly" (optional.Int32) - 
     * @param "ResponseContentType" (optional.String) -  Use &#x60;xml&#x60; or &#x60;json&#x60; to specify the type of response. The default value is &#x60;xml&#x60;. Use this instead of the standard &#x60;accept&#x60; header.
@return InlineResponseDefault101
*/

type TransactionsApiPostReversepaymentOpts struct {
    ApiLogin optional.String
    ApiTransKey optional.String
    ProviderId optional.Int32
    TransactionId optional.String
    AccountNo optional.String
    VerifyOnly optional.Int32
    ResponseContentType optional.String
}

func (a *TransactionsApiService) PostReversepayment(ctx context.Context, localVarOptionals *TransactionsApiPostReversepaymentOpts) (InlineResponseDefault101, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponseDefault101
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/reversePayment"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ResponseContentType.IsSet() {
		localVarHeaderParams["response-content-type"] = parameterToString(localVarOptionals.ResponseContentType.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.ApiLogin.IsSet() {
		localVarFormParams.Add("apiLogin", parameterToString(localVarOptionals.ApiLogin.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ApiTransKey.IsSet() {
		localVarFormParams.Add("apiTransKey", parameterToString(localVarOptionals.ApiTransKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderId.IsSet() {
		localVarFormParams.Add("providerId", parameterToString(localVarOptionals.ProviderId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TransactionId.IsSet() {
		localVarFormParams.Add("transactionId", parameterToString(localVarOptionals.TransactionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AccountNo.IsSet() {
		localVarFormParams.Add("accountNo", parameterToString(localVarOptionals.AccountNo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VerifyOnly.IsSet() {
		localVarFormParams.Add("verifyOnly", parameterToString(localVarOptionals.VerifyOnly.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v InlineResponseDefault101
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
TransactionsApiService Search Biller Directory
Use the Search Biller Directory endpoint to find billers in the &lt;&lt;glossary:RPPS&gt;&gt; database. Pass &#x60;billerName&#x60; (required), &#x60;billerState&#x60; (recommended) and &#x60;billerAccountNo&#x60; (optional). If the biller is in the RPPS database, the endpoint returns the RPPS biller ID (&#x60;rpps_biller_id&#x60;), which you pass in the &lt;a href&#x3D;\&quot;ref:post_addrppsbiller\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Add RPPS Biller&lt;/a&gt; endpoint call. If the biller is not present, use &lt;a href&#x3D;\&quot;ref:post_addpaperbiller\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Add Paper Biller&lt;/a&gt; to add the biller.  If the biller is present in the RPPS directory, the endpoint might return &#x60;biller_account_no_patterns&#x60;, which you can use as a mask to validate the account number.  See &lt;a href&#x3D;\&quot;doc:creating-a-billpay-transaction\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Creating a Billpay Transaction&lt;/a&gt; for instructions on using this endpoint.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *TransactionsApiPostSearchbillerdirectoryOpts - Optional Parameters:
     * @param "ApiLogin" (optional.String) - 
     * @param "ApiTransKey" (optional.String) - 
     * @param "ProviderId" (optional.Int32) - 
     * @param "TransactionId" (optional.String) - 
     * @param "BillerAccountNo" (optional.String) - 
     * @param "BillerName" (optional.String) - 
     * @param "BillerState" (optional.String) - 
     * @param "ResponseContentType" (optional.String) -  Use &#x60;xml&#x60; or &#x60;json&#x60; to specify the type of response. The default value is &#x60;xml&#x60;. Use this instead of the standard &#x60;accept&#x60; header.
@return InlineResponseDefault107
*/

type TransactionsApiPostSearchbillerdirectoryOpts struct {
    ApiLogin optional.String
    ApiTransKey optional.String
    ProviderId optional.Int32
    TransactionId optional.String
    BillerAccountNo optional.String
    BillerName optional.String
    BillerState optional.String
    ResponseContentType optional.String
}

func (a *TransactionsApiService) PostSearchbillerdirectory(ctx context.Context, localVarOptionals *TransactionsApiPostSearchbillerdirectoryOpts) (InlineResponseDefault107, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponseDefault107
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/searchBillerDirectory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ResponseContentType.IsSet() {
		localVarHeaderParams["response-content-type"] = parameterToString(localVarOptionals.ResponseContentType.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.ApiLogin.IsSet() {
		localVarFormParams.Add("apiLogin", parameterToString(localVarOptionals.ApiLogin.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ApiTransKey.IsSet() {
		localVarFormParams.Add("apiTransKey", parameterToString(localVarOptionals.ApiTransKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderId.IsSet() {
		localVarFormParams.Add("providerId", parameterToString(localVarOptionals.ProviderId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TransactionId.IsSet() {
		localVarFormParams.Add("transactionId", parameterToString(localVarOptionals.TransactionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BillerAccountNo.IsSet() {
		localVarFormParams.Add("billerAccountNo", parameterToString(localVarOptionals.BillerAccountNo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BillerName.IsSet() {
		localVarFormParams.Add("billerName", parameterToString(localVarOptionals.BillerName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BillerState.IsSet() {
		localVarFormParams.Add("billerState", parameterToString(localVarOptionals.BillerState.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v InlineResponseDefault107
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
TransactionsApiService Update Payment
Use the Update Payment endpoint to update the number of hold days for a pending payment that was created with the &lt;a href&#x3D;\&quot;ref:post_createpayment\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Create Payment&lt;/a&gt; endpoint. You cannot use this endpoint to update payments created with the &lt;a href&#x3D;\&quot;ref:post_createaccounttransfer\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Create Account Transfer&lt;/a&gt; endpoint.  Consult the &lt;a href&#x3D;\&quot;doc:creating-a-payment\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Creating a Payment&lt;/a&gt; guide for instructions on using this endpoint.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *TransactionsApiPostUpdatepaymentOpts - Optional Parameters:
     * @param "ApiLogin" (optional.String) - 
     * @param "ApiTransKey" (optional.String) - 
     * @param "ProviderId" (optional.Int32) - 
     * @param "TransactionId" (optional.String) - 
     * @param "AccountNo" (optional.String) - 
     * @param "PmtId" (optional.Int32) - 
     * @param "HoldDays" (optional.Int32) - 
     * @param "ResponseContentType" (optional.String) -  Use &#x60;xml&#x60; or &#x60;json&#x60; to specify the type of response. The default value is &#x60;xml&#x60;. Use this instead of the standard &#x60;accept&#x60; header.
@return InlineResponseDefault16
*/

type TransactionsApiPostUpdatepaymentOpts struct {
    ApiLogin optional.String
    ApiTransKey optional.String
    ProviderId optional.Int32
    TransactionId optional.String
    AccountNo optional.String
    PmtId optional.Int32
    HoldDays optional.Int32
    ResponseContentType optional.String
}

func (a *TransactionsApiService) PostUpdatepayment(ctx context.Context, localVarOptionals *TransactionsApiPostUpdatepaymentOpts) (InlineResponseDefault16, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponseDefault16
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/updatePayment"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ResponseContentType.IsSet() {
		localVarHeaderParams["response-content-type"] = parameterToString(localVarOptionals.ResponseContentType.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.ApiLogin.IsSet() {
		localVarFormParams.Add("apiLogin", parameterToString(localVarOptionals.ApiLogin.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ApiTransKey.IsSet() {
		localVarFormParams.Add("apiTransKey", parameterToString(localVarOptionals.ApiTransKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderId.IsSet() {
		localVarFormParams.Add("providerId", parameterToString(localVarOptionals.ProviderId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TransactionId.IsSet() {
		localVarFormParams.Add("transactionId", parameterToString(localVarOptionals.TransactionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AccountNo.IsSet() {
		localVarFormParams.Add("accountNo", parameterToString(localVarOptionals.AccountNo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PmtId.IsSet() {
		localVarFormParams.Add("pmtId", parameterToString(localVarOptionals.PmtId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HoldDays.IsSet() {
		localVarFormParams.Add("holdDays", parameterToString(localVarOptionals.HoldDays.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v InlineResponseDefault16
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
TransactionsApiService Update Pending Merchant Credit
Use the Update Pending Merchant Credit endpoint to post or post and hold a merchant credit if you are handling your own disputes. The threshold for manual review of merchant credits is set during product configuration using the ZREVW product parameter.  To use this endpoint, first, use the &lt;a href&#x3D;\&quot;ref:post_getpendingmerchantcredit\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Get Pending Merchant Credit&lt;/a&gt; endpoint to retrieve the &#x60;settle_id&#x60; value, then pass it in the &#x60;settleId&#x60; parameter. Use &#x60;type&#x60; to specify whether to post or post and hold.  When the Galileo system receives the call to this endpoint, the credit is queued for processing.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *TransactionsApiPostUpdatependingmerchantcreditOpts - Optional Parameters:
     * @param "ApiLogin" (optional.String) - 
     * @param "ApiTransKey" (optional.String) - 
     * @param "ProviderId" (optional.Int32) - 
     * @param "TransactionId" (optional.String) - 
     * @param "SettleId" (optional.String) - 
     * @param "Type_" (optional.String) - 
     * @param "ProgramId" (optional.Int32) - 
     * @param "ResponseContentType" (optional.String) -  Use &#x60;xml&#x60; or &#x60;json&#x60; to specify the type of response. The default value is &#x60;xml&#x60;. Use this instead of the standard &#x60;accept&#x60; header.
@return InlineResponseDefault16
*/

type TransactionsApiPostUpdatependingmerchantcreditOpts struct {
    ApiLogin optional.String
    ApiTransKey optional.String
    ProviderId optional.Int32
    TransactionId optional.String
    SettleId optional.String
    Type_ optional.String
    ProgramId optional.Int32
    ResponseContentType optional.String
}

func (a *TransactionsApiService) PostUpdatependingmerchantcredit(ctx context.Context, localVarOptionals *TransactionsApiPostUpdatependingmerchantcreditOpts) (InlineResponseDefault16, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponseDefault16
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/updatePendingMerchantCredit"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ResponseContentType.IsSet() {
		localVarHeaderParams["response-content-type"] = parameterToString(localVarOptionals.ResponseContentType.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.ApiLogin.IsSet() {
		localVarFormParams.Add("apiLogin", parameterToString(localVarOptionals.ApiLogin.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ApiTransKey.IsSet() {
		localVarFormParams.Add("apiTransKey", parameterToString(localVarOptionals.ApiTransKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderId.IsSet() {
		localVarFormParams.Add("providerId", parameterToString(localVarOptionals.ProviderId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TransactionId.IsSet() {
		localVarFormParams.Add("transactionId", parameterToString(localVarOptionals.TransactionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SettleId.IsSet() {
		localVarFormParams.Add("settleId", parameterToString(localVarOptionals.SettleId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarFormParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProgramId.IsSet() {
		localVarFormParams.Add("programId", parameterToString(localVarOptionals.ProgramId.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v InlineResponseDefault16
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
